## Vue组件数据通信方案

### 1. prop, $emit

> 父组件将数据以prop传给子组件，子组件`emit`出来

```
// 父组件
<template>
  <div class="container">
    <div class="title">{{title}}</div>
    <child @changeTitle="parentTitle"></child>
  </div>
</template>

<script>
import Child from "./component/child.vue";

export default {
  name: "demo",
  data: function() {
    return {
      title: null
    };
  },
  components: {
    Child
  },
  methods: {
    parentTitle(e) {
      this.title = e;
    }
  }
};
</script>
```

```
// 子组件
<template>
  <div class="center">
    <button @click="childTitle">我给父组件赋值</button>
  </div>
</template>

<script>
export default {
  name: 'demo',
  data() {
    return {
      key: 1
    };
  },
  methods: {
    childTitle() {
      this.$emit('changeTitle', `我给父组件的第${this.key}次`);
      this.key++;
    }
  }
};
</script>
```

### 2. 创建一个Vue实例用来承载事件处理（适合处理兄弟组件）

> 该方法是创建了一个空的Vue实例，当做`$emit`事件的处理中心，通过它来触发以及监听事件，方便地实现了任意组件间的通信

```
// 父组件
<template>
  <div class="container">
    <child1 :Event="Event"></child1>
    <child2 :Event="Event"></child2>
    <child3 :Event="Event"></child3>
  </div>
</template>

<script>
import Vue from "vue";

import Child1 from "./component/child1.vue";
import Child2 from "./component/child2.vue";
import Child3 from "./component/child3.vue";

const Event = new Vue();

export default {
  name: "demo",
  data: function() {
    return {
      Event: Event
    };
  },
  components: {
    Child1,
    Child2,
    Child3
  },
};
</script>
```

```
// 子组件1
<template>
  <div class="center">
    1.我的名字是：{{name}}
    <button @click="send">我给3组件赋值</button>
  </div>
</template>

<script>
export default{
  name: "demo1",
  data() {
    return {
      name: "政采云"
    };
  },
  props: {
    Event
  },
  methods: {
    send() {
      this.Event.$emit("message-a", this.name);
    }
  }
};
</script>
```

```
// 子组件3
<template>
  <div class="center">我的名字是{{name}}，今年{{age}}岁</div>
</template>

<script>
export default{
  name: 'demo3',
  data() {
    return {
      name: '',
      age: ''
    };
  },
  props: {
    Event
  },
  mounted() {
    this.Event.$on('message-a', name => {
      this.name = name;
    });
    this.Event.$on('message-b', age => {
      this.age = age;
    });
  },
};
</script>
```

### 3. Vuex（适合维护数据，但是维护事件欠缺了些）

> 统一维护一份共同的State数据，方便组件间共同调用

### 4. `$attrs`, `$listeners`（适合父子组件）

`$attrs`包含了父组件作用域里不作为prop被识别的且获取的特性绑定（class和style除外）。可以通过`v-bind="$attrs"`传入内部组件

`$listeners`： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件 

```
// 父组件
<template>
  <div class="container">
    <button style="backgroundColor:lightgray" @click="reduce">减dd</button>
    <child1 :aa="aa" :bb="bb" :cc="cc" :dd="dd" @reduce="reduce"></child1>
  </div>
</template>

<script>
import Child1 from './component/child1.vue';
export default {
  name: 'demo',
  data: function() {
    return {
      aa: 1,
      bb: 2,
      cc: 3,
      dd: 100
    };
  },
  components: {
    Child1
  },
  methods: {
    reduce() {
      this.dd--;
    }
  }
};
</script>
```

```
// 子组件1
<template>
  <div>
    <div class="center">
      <p>aa:{{aa}}</p>
      <p>child1的$attrs:{{$attrs}}</p>
      <button @click="this.reduce1">组件1减dd</button>
    </div>
    <child2 v-bind="$attrs" v-on="$listeners"></child2>
  </div>
</template>

<script>
import child2 from './child2.vue';
export default {
  name: 'demo1',
  data() {
    return {};
  },
  props: {
    aa: Number
  },
  components: {
    child2
  },
  methods: {
    reduce1() {
      this.$emit('reduce');
    }
  }
};
</script>
```

```
// 子组件2
<template>
  <div>
    <div class="center">
      <p>bb:{{bb}}</p>
      <p>child2的$attrs:{{$attrs}}</p>
      <button @click="this.reduce2">组件2减dd</button>
    </div>
    <child3 v-bind="$attrs"></child3>
  </div>
</template>

<script>
import child3 from './child3.vue';
export default {
  name: 'demo1',
  data() {
    return {};
  },
  props: {
    bb: Number
  },
  components: {
    child3
  },
  methods: {
    reduce2() {
      this.$emit('reduce');
    }
  }
};
</script>
```

```
// 子组件3
<template>
  <div class="center">
    <p>child3的$attrs:{{$attrs}}</p>
  </div>
</template>

<script>
export default {
  name: 'demo3',
  data() {
    return {};
  },
  props: {
    dd: String
  },
};
</script>
```

### 5. provide & inject(比方法四更优雅)

> Vue 2.2 版本以后新增了这两个 API ， 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。 简单来说，就是父组件通过 Provider 传入变量，任意子孙组件通过 Inject 来拿到变量

```
// 父组件
<template>
  <div class="container">
    <button @click="this.changeName">我要改名字了</button>
    <p>我的名字：{{name}}</p>
    <child1></child1>
  </div>
</template>

<script>
import Child1 from './component/child1.vue';
export default {
  name: 'demo',
  data: function() {
    return {
      name: '政采云'
    };
  },
  // provide() {
  //   return {
  //     name: this.name //这种绑定方式是不可响应的
  //   };
  // },
  provide() {
    return {
      obj: this
    };
  },
  components: {
    Child1
  },
  methods: {
    changeName() {
      this.name = '政采云前端';
    }
  }
};
</script>
```

```
// 子组件
<template>
  <div>
    <div class="center">
      <!-- <p>子组件名字:{{name}}</p> -->
      <p>子组件名字:{{this.obj.name}}</p>
    </div>
    <child2></child2>
  </div>
</template>

<script>
import child2 from './child2.vue';

export default {
  name: 'demo1',
  data() {
    return {};
  },
  props: {},
  // inject: ["name"],
  inject: {
    obj: {
      default: () => {
        return {};
      }
    }
  },
  components: {
    child2
  },
};
</script>
```

Provide 和 Inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。

所以，如果采用的是我代码中注释的方式，父级的 name 如果改变了，子组件this.name 是不会改变的，仍然是 政采云 ，而当采用代码中传入一个监听对象，修改对象中属性值，是可以监听到修改的。

Provider / Inject 在项目中需要有较多公共传参时使用还是颇为方便的

### 6. `$parent`,`$children`,`$refs`

适用于父子通信

### 7. 总结


| 类型 | 方法 |
| :-: | :-- |
| 父子通信 | `Props / $emit`，`$emit / $on`，Vuex，`$attrs / $listeners`，`provide/inject`，`$parent / $children＆$refs` |
| 兄弟通信 | `$emit / $on`，Vuex |
| 跨代通信 | `$emit / $on`，Vuex，provide / inject，`$attrs / $listeners` |

| 类型 | 推荐 |
| :-- | :-: |
| 最常用的（父子） | props，$emit |
| 高级组件 | provide&inject |
| 适用性最广的 | Vuex |
| 兄弟通信 | 新建一个Vue实例 |
| 很好用的小方法 | $ref |


## 强制DOM刷新

有时候在Vue中响应式依赖还不够强大，导致一些时候我们想要使用强制刷新，比如我的这个![demo](https://github.com/luvsunlight/js-archive-creator)。但是官方的api`vm.$forceUpdate`只能影响实例本身和插入插槽内容的子组件，而不是所有子组件，如果我们想要让所有的子组件刷新该怎么做呢

```
<template>
    <div v-if="!update">
        ...
    </div>
</template>

<script>
import Vue from "vue"
export default {
    data() {
        return {
            update:false
        }
    },
    ...
    methods: {
        foo() {
            this.update = true
            Vue.$nextTick(()=>{
                this.uodate = false
            })
        }
    }
}
</script>
<style>
    ...
</style>
```

最关键的地方就是我们需要强制重新渲染的元素用一个值来控制`v-if`，然后在需要强制刷新DOM的事件里，先将update赋值为`false`，再在DOM渲染完后将其赋值为`true`，强制令整个DOM销毁再建立，即达到强制刷新的目的