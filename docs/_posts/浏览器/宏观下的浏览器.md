## 浏览器是什么

浏览器的主要功能是通过向服务器请求并在浏览器窗口中显示它来展现您选择的Web资源，该资源通常是HTML文档，但也可以是PDF，图像或者其他类型的资源，用户实用URL(统一资源标识符)指定资源的位置

浏览器解释和显示HTML的文件在HTMl和CSS规范中指定，它们由W3C（万维网组织维护）

但是，多年以来，浏览器仅遵循部分规范，并开发了自己的扩展程序，这就造成了很多兼容问题

浏览器的用户界面并未在任何规范中指定，它只是源于多年经验中形成良好实践以及浏览器之间的

## 进程和线程

在mac下，打开chrome中的一个页面，我们会发现竟然运行了四个进程，那么这是为什么呢

首先，我们来厘清进程和线程的关系和区别

在通行的`并行计算`中，我们采用的是多线程并行计算，来大大提升性能。

多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的，那么什么又是进程呢？

一个进程就是一个程序的运行实例，即启动一个程序时，操作系统就会为该程序创建一块内存

线程和进程之间的关系存在以下几个特点

* 进程中任何一个线程出错，都会导致整个进程的崩溃
* 线程之间共享进程中的数据
* 进程之间内容相互隔离
* 一个进程关闭之后，操作系统会回收进程所占用的内存

### 浏览器的进化史

首先是单进程浏览器时代，即浏览器的所有功能模块都是运行在同一个进程中，即网络，插件，js运行环境，渲染引擎，和页面（展示模块），一般包括三个线程，网络线程，页面线程（包含页面渲染，页面展现，js环境，插件）和其他线程。单进程下的浏览器存在如下问题

![](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

* 不稳定。早期浏览器借助于插件来实现视频游戏等功能，但是插件最容易出问题，而且根据我们之前提到的线程相互影响，一个插件崩了，整体的浏览器进程就会崩溃,除此之外，渲染引擎也容易崩溃
* 不流畅。从渲染到js执行再到插件的处理全部交给一个页面线程
* 不安全。插件可以用c/c++等语言编写，可以后去到系统的任意资源

然后我们引来的就是现代浏览器，已经解决了上述问题。我们首先来看2008年chrome发布时的进程架构

![](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png)

多进程浏览器具有如下特点

* 页面运行在单独的渲染进程中，页面中的插件也是运行在单独的插件进程中。这样解决了不稳定的问题，一个页面崩溃了或者插件出了问题，都不会影响浏览器和其他页面
* js引擎执行也是运行在单独页面的进程中的，一个页面的加载并不会影响其他页面的加载，因为其他页面的脚本试运行在它们自己的渲染进程中
* 对于安全问题，我们在单页面进程采用了安全沙箱，可以保证页面和插件对系统数据的权限受限

## 浏览器架构

最新的chrome进程架构如下

![](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

包含

* 一个浏览器主进程。负责页面显示，用户交互，子进程管理，同时提供存储等功能
* 一个GPU进程。
* 一个网络进程
* 多个渲染进程
* 多个插件进程

所以我们现在用chrome打开一个页面会产生四个进程，至少是浏览器进程，GPU进程，网络进程，页面的渲染进程

### 渲染引擎

渲染引擎可以呈现HTML和XML文档和图像，它可以通过`插件`或者拓展展示其他类型的数据，例如使用PDF查看器插件显示PDF。但是我们先不考虑这些，只看其显示CSS格式化过的HTML和图像的功能

不同的浏览器使用不同的渲染引擎，IE使用Trident，FireFox使用Gecko，Safari使用WebKit，Chrome和Opera使用Blink（是WebKit的分支）

WebKit是一个开放源代码渲染引擎，最开始是Linux平台的引擎，后来被Apple修改为支持Mac和Windows


## 从输入URL到页面展示

![](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

首先明确在这个过程中需要浏览器中的多个进程一起起作用。浏览器进程负责用户交互，子进程管理和文件存储。网络进程面向渲染进程和浏览器进程等提供网络下载。渲染进程主要负责将html，js，css，图片等资源解析为可以显示和交互的页面。这个从URL到页面开始解析的过程，称之为`导航`

* `浏览器`接收到用户输入的URL请求，`浏览器进程`将URL转给`网络进程`
    * 输入的是搜索内容。则会根据默认的搜索引擎，合成新的URL
    * 输入的是URL。则会根据规则，加上协议，组合成完整的URL
    * 拼接URL之后还会触发一个beforeunload事件
* `网络进程`中发起真正的URL请求
    * 查询是否存在本地资源/缓存是否过期
    * DNS解析/DNS缓存
    * 根据IP地址和端口号，建立TCP连接。如果是HTTPS，还需要建立TLS连接
    * 浏览器端构建请求信息，发起HTTP请求
    * 服务器端接受到请求，生成响应数据，并且发送给网络进程
* `网络进程`接收并处理服务端发来的响应数据
    * 重定向。301或者302，需要重新请求其他URL，一切从头再来
    * 返回不同的相应数据。比如我们这里的页面，响应头的Content-Type就是text/html，如果是一个下载文件，则Content-Type为octet-stream
    * 网络进程接收到了HTML格式的响应数据，并将其提交给浏览器进程
* `浏览器进程`准备渲染进程
    * 浏览器进程为每个页面分配渲染进程，默认情况下一个页面创建一个渲染进程，但是如果是同一站点（同协议+同根域名）的情况会共享同一个渲染进程
    * 渲染进程准备好之后，还不能立即进行文档解析状态，因为此时的文档数据还在网络进程中
* 提交文档。`浏览器进程`将接收到的HTML数据提交给`渲染进程`
    * 浏览器进程一接收到网络进程提交的相应数据之后，就向渲染进程发起`提交文档`的消息
    * 渲染进程接收到该消息之后，会开始准备接收HTML数据，方式是和网络进程建立传输数据的管道
    * 数据传输完毕会，`渲染进程`会返回`确认提交`的信息给浏览器进程
    * `浏览器进程`接收到`渲染进程`确认提交的信息之后，便开始移除旧的文档，然后更新浏览器进程中的页面状态，包括安全状态，地址栏的URL，前进后退的历史状态，并且更新Web页面
* 渲染阶段。渲染进程开始页面解析和子资源加载
    * HTML的解析
    * CSS的解析
    * 布局树的生成
    * 分层
    * 生成绘制指令
    * 分块
    * 光栅化
    * 合成
    * 显示
