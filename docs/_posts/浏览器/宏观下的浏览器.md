## 1. 进程和线程

在mac下，打开chrome中的一个页面，我们会发现竟然运行了四个进程，那么这是为什么呢

首先，我们来厘清进程和线程的关系和区别

在通行的`并行计算`中，我们采用的是多线程并行计算，来大大提升性能。

多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的，那么什么又是进程呢？

一个进程就是一个程序的运行实例，即启动一个程序时，操作系统就会为该程序创建一块内存

线程和进程之间的关系存在以下几个特点

* 进程中任何一个线程出错，都会导致整个进程的崩溃
* 线程之间共享进程中的数据
* 进程之间内容相互隔离
* 一个进程关闭之后，操作系统会回收进程所占用的内存

### 浏览器的进化史

首先是单进程浏览器时代，即浏览器的所有功能模块都是运行在同一个进程中，即网络，插件，js运行环境，渲染引擎，和页面（展示模块），一般包括三个线程，网络线程，页面线程（包含页面渲染，页面展现，js环境，插件）和其他线程。单进程下的浏览器存在如下问题

![](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

* 不稳定。早期浏览器借助于插件来实现视频游戏等功能，但是插件最容易出问题，而且根据我们之前提到的线程相互影响，一个插件崩了，整体的浏览器进程就会崩溃,除此之外，渲染引擎也容易崩溃
* 不流畅。从渲染到js执行再到插件的处理全部交给一个页面线程
* 不安全。插件可以用c/c++等语言编写，可以后去到系统的任意资源

然后我们引来的就是现代浏览器，已经解决了上述问题。我们首先来看2008年chrome发布时的进程架构

![](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png)

多进程浏览器具有如下特点

* 页面运行在单独的渲染进程中，页面中的插件也是运行在单独的插件进程中。这样解决了不稳定的问题，一个页面崩溃了或者插件出了问题，都不会影响浏览器和其他页面
* js引擎执行也是运行在单独页面的进程中的，一个页面的加载并不会影响其他页面的加载，因为其他页面的脚本试运行在它们自己的渲染进程中
* 对于安全问题，我们在单页面进程采用了安全沙箱，可以保证页面和插件对系统数据的权限受限

最新的chrome进程架构如下

![](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

包含

* 一个浏览器主进程。负责页面显示，用户交互，子进程管理，同时提供存储等功能
* 一个GPU进程。
* 一个网络进程
* 多个渲染进程
* 多个插件进程

所以我们现在用chrome打开一个页面会产生四个进程，至少是浏览器进程，GPU进程，网络进程，页面的渲染进程

## 从输入URL到页面展示

![](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

首先明确在这个过程中需要浏览器中的多个进程一起起作用。浏览器进程负责用户交互，子进程管理和文件存储。网络进程面向渲染进程和浏览器进程等提供网络下载。渲染进程主要负责将html，js，css，图片等资源解析为可以显示和交互的页面。这个从URL到页面开始解析的过程，称之为`导航`

* `浏览器`接收到用户输入的URL请求，`浏览器进程`将URL转给`网络进程`
    * 输入的是搜索内容。则会根据默认的搜索引擎，合成新的URL
    * 输入的是URL。则会根据规则，加上协议，组合成完整的URL
    * 拼接URL之后还会触发一个beforeunload事件
* `网络进程`中发起真正的URL请求
    * 查询是否存在本地资源/缓存是否过期
    * DNS解析/DNS缓存
    * 根据IP地址和端口号，建立TCP连接。如果是HTTPS，还需要建立TLS连接
    * 浏览器端构建请求信息，发起HTTP请求
    * 服务器端接受到请求，生成响应数据，并且发送给网络进程
* `网络进程`接收并处理服务端发来的响应数据
    * 重定向。301或者302，需要重新请求其他URL，一切从头再来
    * 返回不同的相应数据。比如我们这里的页面，响应头的Content-Type就是text/html，如果是一个下载文件，则Content-Type为octet-stream
    * 网络进程接收到了HTML格式的响应数据，并将其提交给浏览器进程
* `浏览器进程`准备渲染进程
    * 浏览器进程为每个页面分配渲染进程，默认情况下一个页面创建一个渲染进程，但是如果是同一站点（同协议+同根域名）的情况会共享同一个渲染进程
    * 渲染进程准备好之后，还不能立即进行文档解析状态，因为此时的文档数据还在网络进程中
* 提交文档。`浏览器进程`将接收到的HTML数据提交给`渲染进程`
    * 浏览器进程一接收到网络进程提交的相应数据之后，就向渲染进程发起`提交文档`的消息
    * 渲染进程接收到该消息之后，会开始准备接收HTML数据，方式是和网络进程建立传输数据的管道
    * 数据传输完毕会，`渲染进程`会返回`确认提交`的信息给浏览器进程
    * `浏览器进程`接收到`渲染进程`确认提交的信息之后，便开始移除旧的文档，然后更新浏览器进程中的页面状态，包括安全状态，地址栏的URL，前进后退的历史状态，并且更新Web页面
* 渲染阶段。渲染进程开始页面解析和子资源加载
