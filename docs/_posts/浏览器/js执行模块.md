## 1. js执行上下文

### 变量提升

js代码执行的过程分为两步，一个是编译，一个是执行，或者说一段js代码在执行前需要被js引擎编译，编译完成后才会进入执行阶段。编译过程中，js引擎会将变量的声明部分和函数的声明部分进行提升。其中变量的值初始化为undefined，函数的值则为正常

### js代码的执行流程

#### 1. 编译阶段

> 一段js代码，经过编译，会生成两个部分内容，执行上下文和可执行代码（字节码）

> 执行上下文是js执行一段代码时的运行环境。比如调用一个函数，就会进入该函数的执行上下文。在执行上下文中存在一个变量环境的对象

#### 2. 执行阶段

执行阶段则是严格意义上的一行行执行

## 2. 调用栈

### 创建执行作用域的条件

我们已经知道了js执行上下文是怎么回事，也知道了一段js代码执行需要分为两个步骤，我们来明确什么情况下代码才会发生上述情况

* js执行全局代码时，会编译全局代码并创建全局执行上下文，并且在整个页面的生存周期内，全局执行上下文只有一份
* 当调用一个函数时，函数体内的代码会被编译，并创建函数执行上下文
* eval和with也会动态创建词法作用域/执行上下文

### 函数调用

函数调用就是运行一个函数

以这段代码为例，我们看一下函数调用的过程

```
var a = 2
function add(){
var b = 10
return  a+b
}
add()
```

![](https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png)

首先在编译阶段创建全局执行上下文，里面含有a和add的定义，然后开始执行全局代码，执行到add()时，js引擎判断这是一个函数调用，然后执行以下操作

* 从全局执行上下文中，取出add函数代码
* 编译（创建上下文+可执行代码）
* 执行代码，输出结果

### 调用栈

从上述js代码执行的过程中我们可以看到产生了两个执行上下文，那么我们如何来管理这些执行上下文

> 调用栈是用来管理函数调用关系的一种数据结构

js引擎在上下文创建好后会将执行上下文压入栈中，即`执行上下文栈`，或`调用栈`

### 调用栈溢出（stack overflow）

我们已经知道了调用栈是一个管理执行上下文的数据结构，但是它是有大小的，当入栈的执行上下文数超过了一定数目，即发生了堆栈溢出

一般情况，出现于递归

## 3. 作用域

> 作用域是指在程序中定义变量的区域。通俗地讲，作用域就是变量和函数的可访问范围

块级作用域的作用在于其代码块内部定义的变量在代码块外部是访问不到的，`作用域块内声明的变量不影响块外面的变量`

在es6之前，是没有块级作用域的，这也就导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，形成了变量提升

### 作用域和执行上下文

!> 作用域和执行上下文是两套规则！在es6之前是没有明确的块级作用域的说法的！有的只是执行上下文。这是js设计的缺陷，为了方便没有设计块级作用域（只有函数级和全局）块级作用域是通过执行上下文中的词法环境来实现的

我们已知执行上下文里存在变量环境和词法环境，js引擎通过变量环境来实现函数级作用域

```

function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

foo函数内部刚开始的时候，执行上下文是这样的

![](https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png)

我们可以看到，在函数体内部

* var声明的全部放在了变量环境中
* 最外层的let声明的变量会被放在词法环境中
* 里层的let声明的变量不会进词法环境/变量环境

在执行完let b = 2后进入代码块里，执行上下文是这样的

![](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

我们通过词法环境来实现块级作用域

* 进入代码块中，let/const声明的变量才会被收集此法环境中
* 词法环境内部也是一个小型栈结构，进行LHS查询时遵循栈的顺序，即作用域链
* 在离开代码块后，词法环境会有出栈的操作，销毁代码块里收集在词法环境中的变量

最后代码块执行结束，词法环境中定义的变量就会从词法环境的栈顶弹出

![](https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png)

## 4. 作用域链

### 词法作用域

> 词法作用域，即作用域是由代码中函数声明的位置来决定的

首先我们知道js的作用域是词法作用域，即作用域的范围是根据词法即编译过程中就已经确定的，再通俗一点就是写代码时的结构确定的，和调用栈无关，一个典型的例子如下

```
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "极客邦"
    bar()
}
var myName = "极客时间"
foo()
```

foo()调用的结果是极客时间，原因是foo中定义的myName根据词法作用域的定义，bar中并不能访问到

我们再用执行上下文的眼光来剖析一下这个阶段

![](https://static001.geekbang.org/resource/image/87/f7/87d8bbc2bb62b03131802fba074146f7.png)

如图，bar函数执行上下文中并没有myName的变量环境，如果按照调用栈的顺序的话，就应该找到foo中去了，但是实际情况并非如此

### 作用域链

在每个执行上下文中，除了变量环境和词法环境，还包括一个outer外部引用，用来指向外部的执行上下文

作用域的意思即，我们在查找一个变量时，js引擎首先会在当前的执行上下文中查找该变量

如果当前变量环境没有，则js引擎会在outer所指向的执行上下文中查找,如果还是没有则依次类推，这个查找的链条就被称之为作用域链

## 5. 闭包

闭包的概念我们已经很熟悉了，这里用执行上下文的角度深入解释一下闭包的情形

```
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

上述代码在foo函数执行完成之后，它的执行上下文`从栈顶弹出了`，但是由于返回的setName和getName方法使用了foo函数内部的变量，所以这两个变量仍然保存在内存中（但是要记得之前的执行上下文已经被弹出了，闭包是依附于暴露出来的内部函数）。我们将这种内部函数对外部函数能够引用变量的集合称之为闭包，要注意`闭包只会包含用到的变量`，js引擎通过分析闭包内部函数的词法环境来达成这一点。

!>从底层原理的角度讲，js在编译过程中检测到内部函数，js引擎会对该函数做一次快速的词法扫描，如果有对当前执行上下文的引用，js引擎就会在堆中创建一个closure对象，并且在当前函数的执行上下文中加入该闭包对象，当该函数返回，该函数的执行上下文从调用栈中销毁，但是！返回的内部函数依然保持有对该闭包对象的引用，这个过程，我们称之为闭包（这下就完全清楚了）

> 闭包很占内存，所以如果使用频率不高的话，我们可以将其写成临时变量，以让js引擎触发回收机制，销毁闭包

## 6. this

![](https://static001.geekbang.org/resource/image/b3/8d/b398610fd8060b381d33afc9b86f988d.png)

this的四种情况不用赘述了

箭头函数是this的特殊情况是因为它不会创建自己的执行上下文