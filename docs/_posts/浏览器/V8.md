## 1. JS中的内存机制

如果想要成为前端行业专家，并且打造高性能前端应用，那么我们必须搞清楚JS的内存机制，即JS中的数据是如何存储在内存中的

### 1.1 JS中的类型

#### 语言的数据类型

像c这种，在声明变量之前需要先定义变量类型，我们把这种在使用之前就需要确认其变量数据类型的称为`静态语言`

相反的，我们把在运行过程中需要检查数据类型的语言称之为动态语言，JS就是`动态语言`，因为在声明变量之前并不需要确认其数据类型

在c中，我们将一种类型的数据赋值给另一种类型的数据，编译器会将赋值的数据类型偷偷进行转换，我们将这种偷偷转换类型的操作称之为`隐式类型转换`

#### JS的数据类型

JS是一种`弱类型的，动态的语言`

* 弱类型，意味着不需要告诉引擎这个变量是什么数据类型
* 动态，意味着我们可以使用同一个变量保存不同类型的数据

![](https://static001.geekbang.org/resource/image/85/15/85b87602eac65356c9171bbd023f5715.png)

（这里注意BigInt）

我们知道JS中有上述基础类型，其中除了Object以外，称之为原始类型，Object是引用类型。那么是什么导致了JS中数据类型存在差异呢？就需要了解到内存空间的知识，涉及到了底层原理。

### 1.2 内存空间

在js的执行过程中，主要有三种类型内存空间

* 代码空间
* 栈空间（调用栈，存储执行上下文）
* 堆空间

> 需要提出来的是，原始类型的数据值都是保存在栈中的（执行上下文中的变量环境/词法环境），而引用类型的值是存放在堆中的

:::warning
我们不可以将对象中的数据全部存储在栈中，因为栈是用来维护程序执行上下文的状态的，如果栈空间大了，会影响上下文切换的效率
:::

在执行上下文中，只存储原始类型的数据值，引用类型的变量只存储它在堆中的地址，故在复制的时候，也是只把地址复制过去

## 2. 垃圾回收机制

我们已知原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的，通过这种分配方式，我们解决了数据的内存分配的问题

### 不同语言的垃圾回收机制

分为手动回收和自动回收

比如c是手动回收策略，何时分配内存，何时销毁内存都是由代码控制的

如果一个数据已经不需要了，但是又没有主动销毁，我们称之为`垃圾泄露`

JAVA，python和JS都是用的垃圾回收器，产生的垃圾数据是通过垃圾回收器来释放的

但是我们不能因此不关注内存管理，这对于提升我们的知识深度没有帮助

我们将从栈和堆两个角度来看JS引擎中的垃圾回收只读

### 调用栈中的数据如何回收

即通过调用栈的指针（出栈操作）来销毁栈中的执行上下文数据，比较好理解

### 堆中的数据如何回收

#### 代际假说

这是垃圾回收领域的一个重要的术语

* 大部分对象在内存中的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问
* 不死的对象，会活得更久

#### V8中的垃圾回收

将堆分为新生代和老生代两个区域，新生代中的事生存时间短的对象，新生代中存放的是生存时间久的对象

新生代容量小（1~8M），老生代容量大，对于两种区域，V8使用不同的垃圾回收器（新生代是副垃圾回收期，老生代是主垃圾回收期），以便更高效地实施垃圾回收

两套垃圾回收期都有共通的执行流程

* 标记空间中活动对象和非活动对象。活动对象就是还在使用的对象
* 标记完成后，统一清理内存中没有被标记为可回收的对象
* 内存整理。频繁回收对象之后，内存就会出现大量不连续空间，即内存碎片。（副垃圾回收器不会产生内存碎片）

##### 副垃圾回收器

负责新生区的垃圾回收。大部分小的对象都会被分配到新生区，这个区域虽然空间小，但是垃圾回收还是比较频繁的

该垃圾回收器使用Scavenge算法来处理

![](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

* 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
* 新加入的对象都会存放在对象区域中
* 当对象区域快被写满时，就需要执行一次垃圾清理操作
* 开始标记新生区中对象区的全部数据
* 将存活的对象复制到空闲区域中，同时有序排列。这样就不必进行内存整理了
* 复制完成后，对象区域和空闲区域角色互换

正因为复制操作需要时间成本，为了执行效率，一般将新生区的空间设置得比较小

同时正因为新生区的空间不大，所以很容易装满，引擎采取了对象晋升策略，经过两次垃圾回收还存活，会被移动到老生区中

##### 主垃圾回收器

老生区中的对象，主要包含

* 从新生区中晋升的对象
* 大的对象

在老生区中不能再采取之前的策略了，因为复制是一件很耗时的事，主垃圾回收器是采用`标记——清除`的算法进行垃圾回收的

* 标记过程。从根元素开始，能够访问到的元素称之为活动对象（个人的理解是从当前执行上下文开始向outer递归）（新生区和老生区的标记过程是一样的）
* 垃圾回收过程。清除在标记阶段没有被标记为活动对象的数据
* 内存整理

### 全停顿

我们知道JS是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JS脚本暂停下来，我们将这种行为叫做`全停顿`

对于新生代，因为内存占用空间小，全停顿的影响不大，但是老生代就不一样了，因为页面渲染和JS执行是同一个线程，一旦发生全停顿，甚至可能导致页面无响应

为了解决这个问题，V8通过`增量标记`的策略，将标记过程和JS执行交替进行

![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)

## 3. JS中代码的执行过程

我们已经知道，JS引擎在真正执行一段代码，会有两个阶段

* 编译阶段。这个阶段会生成执行上下文以及将代码编程机器能够理解的形式（字节码），执行上下文包含变量环境，词法环境，outer，this
* 执行字节码

这只是一个粗略的过程

### 编译器和解释器

机器不能直接理解我们写的代码，所以我们需要在执行程序前，把我们写的代码翻译成机器能读懂的机器语言，按照语言的执行流程，可以把语言划分成编译型语言和解释型语言

编译型语言，在程序执行之前，需要经过编译器的编译，目的是输出机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，不需要重新编译，比如c,GO

解释型语言，每次运行都需要通过解释器对程序进行动态的解释和执行，比如python和JS

![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)

在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析，语法分析，生成AST，然后是优化代码，最后生成处理器能够理解的机器码，如果编译成功，就会生成一个可执行的文件

在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析，语法分析，生成AST，然后根据AST生成字节码，最后根据字节码来执行程序，输出结果

### JIT（即时编译）

机器码是机器能够直接读懂的，执行效率非常高，但是整段代码全部转换为机器码很占内存，JIT（即时编译）就是将字节码配合解释器和编译器，即正常情况下我们使用解释器去解释执行字节码，发现hotSpot之后我们将其交给编译器转换为机器码，以备下次使用

![](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png)

### V8是怎么执行一段JS代码的

![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)

（图中解释器解释字节码并不是转化为机器码，而是可以直接执行程序）

#### 生成AST和执行上下文

类似于HTML转换为DOM树，解释器/编译器需要将高级语言写成计算机可以理解的AST，我们可以简单地将AST想象成代码的结构化表示，一些诸如babel，eslint，webpack，vue等等现代化前端工具里都有AST的影子

要生成AST需要经过两个阶段

* 词法分析。将源码拆分为一个个最小的不可拆分的token
* 语法分析，将token转化为AST

生成了AST，再生成该段代码的执行上下文

#### 生成字节码

有了AST和执行上下文，解释器Ignition就登场了，它会根据AST生成字节码，并解释执行字节码

:::tip
其实一开始V8是直接生成机器码的（编译器的流程），这样做执行效率非常高，但是后来在移动端发现内存占用问题，转换后的机器码占用大量的内存。于是才有了现在这套架构
:::

> 字节码就是介于AST和机器码之间的一种代码，但是和特定类型的机器码无关，字节码需要通过解释器将其转换为机器码之后才能进行。但是机器码占用的空间远远超过了字节码

![](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png)

#### 执行代码

之前我们通过`解释器Ignition`来将AST转换为字节码，在执行的过程中，我们还需要`解释器Ignition`来解释执行字节码（不需要转换成机器码）。此外，在Ignition执行字节码时，如果有热点代码（比如一段代码被重复执行很多次），后台的`编译器TurboFan`就会把该段热点的字节码编译成高效的机器码，以备下次使用更加高效，这样可以大大提升代码的执行效率

此外，我们可以把WebAssembly看作是经过TurboFan转换成机器码，所以效率非常高

!> V8执行时间越长，执行效率越高。是因为越来越多的代码成了热点代码，转化为了机器码



