## 1. 渲染流水线

由于渲染机制归于复杂，所以渲染模块在执行过程中会被划分为多个子阶段，输入的HTML经过这些子阶段，最后输出像素，我们把这样的一个处理流程称之为渲染流水线

按照渲染的时间顺序，流水线可以分为如下几个阶段

* 构建DOM树
* 计算CSSOM
* 布局
* 分层
* 绘制
* 分块
* 光栅化
* 合成和显示

### 1.2 构建DOM树

为什么要构建DOM树，因为HTML本质是一种数据的描述格式，浏览器无法直接理解和使用HTML，所以要将HTML转化为可以理解的结构——DOM树

#### 什么是DOM

* 能够直接被渲染引擎理解的内部结构，它提供了对HTML文档结构化的表述
* 从页面的角度上说，DOM是生成页面的基础数据结构
* 从JS的角度上说，DOM提供给JS脚本操作的接口，通过这套接口，JS可以对DOM结构进行访问，从而改变文档的结构，样式和内容
* 从安全的角度来看，DOM是一道安全的防线，一些不安全的内容在DOM解析阶段就被拒之门外了

#### DOM是怎么生成的

在渲染引擎内部，有一个叫HTML解析器的模块。它的工作机制是`网络进程加载了多少资源，HTML解析器便解析多少数据`

网络进程和渲染进程建立管道之后，网络进程接收到数据就往管道里放，渲染进程则接收到数据就开始解析，可以想象成一个双向的动态过程

* 通过分词器，将HTML字节流转换为Token
* 将Token解析为DOM节点，并将DOM节点添加到DOM树中
    * 实际上这个过程就是栈的一个典型的应用场景
    * 入栈的是StartTagToken，则创建一个DOM节点并加入到DOM树中
    * 如果是EndTag标签，则看栈顶的是不是StartTagToken，如果是则弹出，表示该元素被解析完成

值得指出来的是，浏览器具有一定的容错机制，即使我们书写了错误的HTML代码，渲染引擎也不会抛出错误，它会修复无效内容并且继续。这个容错机制并非规范的一部分，它属于浏览器自身的实现

WebKit在HTML解析器的注释如下

> 解析器将标记化的输入解析到文档中，从而建立文档树。如果文档格式正确，则对其进行解析很简单。

不幸的是，我们必须处理许多格式不正确的HTML文档，因此解析器必须容忍错误。

我们必须至少照顾以下错误情况：

明确禁止在某些外部标签内添加要添加的元素。在这种情况下，我们应将所有标签关闭到禁止该元素的标签，然后再添加。
我们不允许直接添加元素。可能是写文档的人忘记了中间的一些标签（或者中间的标签是可选的）。以下标记可能就是这种情况：HTML HEAD BODY TBODY TR TD LI（我忘了吗？）。
我们想在一个内联元素中添加一个block元素。关闭所有内联元素，直到下一个更高的块元素。
如果这样做没有帮助，请关闭元素，直到允许我们添加元素或忽略标签

#### JS是如何影响DOM生成的

如果是遇到了JS脚本，渲染引擎会停止所有的DOM解析，因为接下来的JS可能要修改已经生成的DOM结构

如果是引用的脚本，原理是一样的，先暂停整个DOM的解析，然后下载和执行JS代码

!> 不过上述的是规范的内容，chrome浏览器做了相应的优化，其中一个主要的优化是预解析操作，当渲染引擎接收到字节流之后，会开启一个预解析线程，用来分析HTML中的JS和CSS文件，解析到了之后，预解析线程会提前下载这些文件

我们已知JS线程会阻塞DOM，但是我们也可以用响应的策略来规避，比如使用CDN来加速JS的加载，压缩JS的体积，此外，如果JS中没有操作DOM相关的代码，可以将该JS脚本设置为异步加载，通过async或defer来标记代码，asnyc的脚本一旦加载完成就会立即执行，而defer标记的脚本文件，需要在DOMContentLoaded事件之前执行

DOMContentLoaded触发于HTML被完全解析，这当然包括CSS，JS的下载和解析，但是不包括后续的布局，合成等等，仅仅是DOM完全解析，就会触发该事件

对应的load事件对应于完全加载的页面

### 1.3 样式计算

这个阶段的目的是为了计算出DOM节点中每个元素的具体样式

* 把CSS转换为浏览器能够理解的结构（styleSheet）,我们在控制台里通过document.styleSheets可以访问到该属性
* 转换样式表中的属性值，使其标准化
* 计算出DOM树中每个节点的具体样式
    * css继承
    * 样式层叠

!> CSS文件下载阻塞的话，不会影响DOM树的构建，但是会影响页面的显示。不过浏览器可以有自己的容错机制，如果下载超时，则采用user-agent stylesheet默认样式进行渲染就可以了

!> 在源码中并没有CSSOM这个概念，可以用styleSheets来理解。现在的浏览器经过重构已经没有了渲染树的说法，只有根据DOM树和计算后的样式生成的布局树

#### CSS和JS的阻塞

* DOM解析到了JS脚本后会马上停止DOM的解析，开始执行JS
* JS中有可能存在影响CSSOM的操作，但是因为渲染引擎并不知道有没有这样的操作，所以在执行JS之前一定会先等待CSS的下载和解析（CSSOM）

如果JS代码中出现了如`div.style.color`这样的引用，它是用来操纵CSSOM的，在执行JS之前，需要先解析JS上所有的CSS样式，如果代码里引用了外部的CSS文件，那么在执行JS前，还需要等待外部的CSS文件下载完成，并解析生成CSSOM对象之后,才能执行JS脚本

我们已经知道了CSS和JS对DOM的阻塞作用，我们再来全面地分析一下从请求HTML数据到建立布局树（这个步骤需要完整的DOM树和解析后的CSSOM结构）中间发生的过程，清晰地了解这个过程才能有助于我们更系统地分析白屏原因

![](https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png)

上图是最完整的情况，包含了CSS文件和JS文件都是外部链接的情况，在规范里，CSS文件和JS文件是只有在HTML解析到那里的时候才会开始下载和执行的，但是我们已经了解到了浏览器优化了`预解析阶段`，它会在解析HTML之前执行预解析，并且提前开始`下载`对应的文件

同时HTML解析时，遇到了JS，如果是外部文件则需要等待其下载完成，如果是内联文件/下载好了，则会停止DOM解析，开始JS的执行（因为JS的执行有可能会影响DOM树的结构），但是JS中也有可能存在影响CSSOM的结构，所以JS的执行还需要等待CSS文件的下载和解析，生成了CSSOM之后，才会去执行JS，执行完毕以后再继续构建DOM

defer标记的脚本文件会异步下载，并且等到DOM解析完成之后执行，不会阻塞页面渲染

async标记的脚本，下载完成后立即执行，有可能会阻塞页面渲染

### 1.4 布局

我们有了DOM树的结构和DOM树中元素的样式，但是这还不够，我们需要计算出DOM树种可见元素的几何位置，我们把这个计算过程叫做布局

* 创建布局树。DOM树还含有很多不可见的元素，比如head标签，所以在显示之前，我们还要额外地构建一颗只包含可见元素布局树
* 布局计算。我们根据一颗完整的布局树，计算布局树节点的坐标位置

### 1.5 分层

现在我们有了布局树，而且每个元素的具体位置都计算出来了，但是我们还不能立即着手绘制页面

因为页面中还有很多复杂的效果，比如复杂的3D变换，页面滚动，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并且生成一颗对应的图层树

> 我们就知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层，只有满足如下条件的节点才会创建为新的图层

* 拥有层叠上下文属性的元素
    * position: fixed
    * z-index
    * filter:blue(5px)
    * opacity
* 需要裁减的地方也会被创建为图层(即内容超过了限定的范围，即需要裁减)

### 1.6 绘制

在构建完图层树之后，渲染引擎会对图层树中的每个图层进行绘制

渲染引擎绘制一个图层的方式是将一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组合成一个待绘制列表

### 1.7 栅格化

上述的绘制列表只是一个类似消息队列的机制，它描述了绘制的基础机制，实际上绘制操作是由渲染引擎中的`合成线程`来完成。我们已知渲染进程是一整个进程，前面的DOM树，style格式化，布局树，分层和生成绘制列表都是由该进程的主线程完成的，但是绘制则是由其中的`合成线程`来完成的

![](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png)

主线程负责生成绘制列表（即我们上一步操作），主线程会把该绘制列表提交给合成线程

> 视口。通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口

如果整体页面的内容很多的话，一次渲染是很大的开销，基于这个原因，合成线程会将图层划分瓦片（tile）

* 主线程生成绘制列表，然后交给合成线程
* 合成线程将图层划分为瓦片（256x256 / 512x512）
* 合成线程按照视口附近的图块来优先生成位图
* 将图块转换为位图的过程就是`栅格化`，通常栅格化的过程都会使用GPU来加速生成，该过程涉及到和GPU进程的通信，绘制的内容存储在GPU的内存中

### 1.8 合成和显示

一旦图块都被光栅化，合成线程就会生成一个绘制图块的命令，然后将该命令提交给浏览器进程

浏览器进程里接收到该命令，将其页面内容绘制到内存中，然后再将内存显示在屏幕上

#### 显示器是怎么显示图像的

每个显示器都有固定的刷新频率，通常是60hz，也就是每秒更新60张图片，更新的图片都源自于显卡中一个叫做`前缓冲区`的地方，显示器要做的事就是每秒60次从前缓冲区读取图像，并且将读取到的图像显示到显示器上

`显卡`的任务就是合成新的图像，并将图像保存在`后缓冲区`中，系统再让后缓冲区和前缓冲区互换，通常情况下，显卡的更新频率和显示器的刷新频率保持一致。但是一些复杂的任务里，显卡刷新的频率变慢，这样就会造成视觉的卡顿

#### 帧和帧率

当我们操作页面时，屏幕上会出现产生动画的效果，所以我们能感觉到有动画的效果，是因为在执行这些操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区

正常显示器的刷新频率是60次/秒，这也意味着渲染引擎需要每秒更新60次到显卡的后缓冲区，才能保证动画效果的流畅性

我们将渲染流水线生成的每一幅图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率

要解决卡顿问题，就要解决每一帧生成时间过久的问题，为此chrome对浏览器渲染方式做了大量的工作，最有成效的策略就是引入了分层和合成机制

#### 如何生成一帧图像

生成任意一帧的方式，有重绘，重排和合成三种方式。通常渲染路径越长，生成图像花费的时间越多，最有效率的生成帧的形式就是`合成`

用PS的思维去理解，就是一个网页可以想象成很多图片叠加在一起，每个图片就对应一个图层。在chrome的渲染流水线中，在生成布局树（只保留可视的元素）之后，还需要对布局树进行分层，生成层树，其中每一个节点对应一个图层。然后是生成绘制指令，进阶着在合成线程中进行光栅化处理，每一个图层生成一个图片，并且将这些图片合成为一张图片，最终将生成的图片发送到后缓冲区（类似于打印技术中的rgba合成）

!> 合成操作是在合成线程上完成的，这也意味着合成操作时，是不会影响到主线程的，这也就是为什么经常主线程卡住了，但是CSS动画依然能够执行

分层和合成的定位（宏观层面）是生成布局树后分层，然后在合成线程中合成。分块是另一个角度去提升渲染效率（微观层面），页面比屏幕大，合成线程将每个图层分割成大小固定的图块，并且优先绘制靠近视口的图块

但是即使这样，因为涉及到纹理上传的问题，计算机内存上传到GPU内存的操作比较慢，chrome又采取了一个策略，在首次合成图块的时候使用一个低分辨率的图片，在首次显示页面内容时，将这个图片显示出来，然后合成器继续绘制正常比例的网页内容。当正常比例的网页内容完成之后，再替换掉当前显示的低分辨率内容，这样可以有效减少白屏时间

#### 如何利用分层技术优化代码

如果使用JS来写动画效果，会牵涉到整个渲染流水线，所以JS的绘制效率会很低下

这时，我们可以用`will-change`属性来告诉渲染引擎我们将会对该元素做一些特效变换。这个时候，渲染引擎会将该元素单独实现一个层，等到变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，就可以大大提升渲染的效率，这也是`CSS动画比JS动画高效的原因`

!> 需要注意的是，为某个元素单独实现一层固然可以提升渲染效率，但是也会多占内存，所以要恰当使用

```
.box {
will-change: transform, opacity;
}
```

要记住能够在合成线程中完成的任务都不会改变图层的内容，比如几何变换，透明度变换，阴影等。比如滚动页面（如果不涉及懒加载），页面内容不变化，这么做其实只是对图层做上下移动，直接在合成线程中就可以完成了，又比如声明了will-change的元素，会单独生成一层，在变化时，只需要在合成线程中设置变动即可，不需要重新经历渲染流水线

### 1.9 重绘，重排，合成

![](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

我们可以看到渲染进程的主要工作流程如上所示。对于重排，需要更新完整的渲染流水线，故损耗较高

对于重绘，只需要更新Style，绘制列表和栅格化过程，相对代价较小

通过CSS实现一些变形，渐变，动画等特效，这是由CSS触发的，并且在合成线程上执行的，这个过程为`合成`，不触发重绘也不触发重排，并且合成操作本身速度非常快，所以执行合成是效率最高的方式

## 2. 利用开发者工具进行性能分析

我们已经知道了页面循环系统，它是页面调度任务的基石，V8引擎是负责执行JS的。接下来，我们要了解页面具体的渲染过程，要想深入了解浏览器内部工作原理，ChromeDevTools是很重要的开发调试工具

![](https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png)

我们如果想要去做一些实践性的项目优化，理解其背后的理论至关重要

### 网络面板

![](https://static001.geekbang.org/resource/image/46/57/46fba54f54b9bd43918308f9f1ae1357.png)

#### 控制器

![](https://static001.geekbang.org/resource/image/f0/42/f02477088c0499247e0ed37f46ad2a42.png)

* 开始/暂停抓包
* 全局搜索，在所有的下载资源中进行搜索
* Disable cache
* online按钮，可以限制带宽，模拟弱网

#### 过滤器

#### 抓图信息

#### 时间线

可以直观地感受页面的加载过程

#### 详细列表

详细记录了每个资源从发起请求到完成请求这中间所有状态的过程，以及最终请求完成的数据信息，通过该列表，你就能很容易地去诊断一些网络问题

* 列表的属性，如Name,Status,Type,Initiator
* 详细信息，点击之后就会出现
* 单个资源的时间线
    * Queuing。当浏览器发起一个请求时，会有很多原因导致该请求不能被立即执行
        * 页面中资源具有优先级。CSS，HTML，JS优先级高于图片，视频，音频
        * 浏览器会为每个域名最多维护6个TCP链接
        * 网络进程在为数据分配磁盘空间也需要时间
    * Stalled（停滞）。在发起链接之前，还有一些原因可能导致链接过程被推迟
    * 如果有代理服务器，还会增加一个`Proxy Negotiation`阶段
    * Initial Connection阶段，和服务器简历链接阶段，如果是HTTPS还有一个SSL握手时间
    * Request Sent。和服务器建立好链接之后，网络进程会准备请求数据
    * Waiting(TTFB)，通常也叫做`第一字节时间`，这个是反应服务端响应速度的重要指标
    * Content Download即陆续接受完整数据的阶段

上面是网络面板中时间线的含义，我们可以从时间线中刚分析出响应的优化策略

* Queue时间过久。可能是浏览器为每个域名最多维护6个链接导致
    * 我们可以把一个站点下的资源放在多个域名下面（域名分片技术）
    * HTTP2（取消了TCP链接的限制）
* TTFB时间过久
    * 服务器生成页面数据的时间过久
        * 提高服务器的处理速度
    * 网络的原因
        * 使用CDN缓存
    * 发送请求头带上了多余的用户信息
        * 减少不必要的cookie数据
* ContentDownload过久
    * 可能是字节数太多，我们要尽可能减少文件大小

#### 下载信息概要

* DOMContentLoaded，说明页面已经构建好DOM了，意味着DOM所需的HTML，JS，CSS文件都已经下载完成了
* Load，说明浏览器已经加载了所有的资源

## 3. 系统的渲染优化

### 网络阶段

第一个阶段应该是网络阶段，即从从网络请求发出到渲染进程发起请求（渲染进程告诉主进程资源已经下载好了，可以开始渲染）,可以通过网络面板来查看

* Queue时间过久。可能是浏览器为每个域名最多维护6个链接导致
* 我们可以把一个站点下的资源放在多个域名下面（域名分片技术）
* HTTP2（取消了TCP链接的限制）
* TTFB时间过久
    * 服务器生成页面数据的时间过久
        * 提高服务器的处理速度
    * 网络的原因
        * 使用CDN缓存
    * 发送请求头带上了多余的用户信息
        * 减少不必要的cookie数据
* ContentDownload过久
     * Queue时间过久。可能是浏览器为每个域名最多维护6个链接导致
* 我们可以把一个站点下的资源放在多个域名下面（域名分片技术）
    * HTTP2（取消了TCP链接的限制）
    * TTFB时间过久
        * 服务器生成页面数据的时间过久
            * 提高服务器的处理速度
        * 网络的原因
            * 使用CDN缓存
        * 发送请求头带上了多余的用户信息
          * 可能是字节数太多，我们要尽可能减少文件大小
          
### 加载阶段

即从发起请求到渲染出完整页面的阶段，主要影响因素是网络和JS脚本，我们也可以称之为页面的首次渲染

![](https://static001.geekbang.org/resource/image/92/0a/925058a17cfbedff54e746db798c500a.png)

!> 并非所有资源都会阻塞页面的首次渲染，图片，音频，视频等不会阻塞页面的首次渲染，而JS，HTML，CSS会阻塞（关键资源）

> 该阶段的运行机制

* 提交数据之后，渲染进程会创建一个`空白页面`，通常称之为`解析白屏`，并且等待CSS文件和JS的加载完成，生成CSSOM和DOM，然后合成布局树
* 等首次渲染完成，就开始进入完整页面的生成阶段

> 该阶段的优化思路

* 关键资源个数
    * 尽可能内联CSS和JS（关键资源不需要下载）
    * 不涉及DOM操作以及不重要的JS脚本用defer或者async
    * 对于CSS资源，添加媒体取消组织显示的标志
* 关键资源大小
    * 压缩CSS和JS
    * 移除注释内容
* 关键资源需要多少个RTT(Round Trip Time)，RTT就是一个数据包的往返时延，这个主要是假如一个HTPP的数据包在14k左右，所以一个0.1M的页面就需要被拆分为8个包来传输，即8个RTT。（对于CSS和JS，因为存在预解析，CSS和JS几乎是同时开始下载的，所以只需要考虑最大的那个数据即可）
    * 使用CDN减少RTT的时间
    * 减少关键资源的个数和大小来减少RTT的时间

### 交互阶段

页面加载完成以后的交互阶段。实际上就是在谈渲染进程渲染帧的速度

![](https://static001.geekbang.org/resource/image/4a/0c/4a942e53f9358c9c4634c310335cc10c.png)

这个过程和加载阶段不一样的是

* 没有了加载关键资源
* 构建DOM
* 构建CSSOM
* 通常由JS触发交互动画

在该阶段，大部分情况下，生成一个新的帧都是由JS通过修改DOM或者CSSOM来触发的，另外一部分是由CSS来触发的

> 该阶段的优化思路

* 减少JS脚本执行时间（原则是不要一次霸占太久主线程）
    * 将一次执行的函数分解为多个任务
    * 采用WebWorker，可以理解成主线程以外的一个线程，在该线程中可以执行JS脚本，但是没有DOM，CSSOM环境，适合执行一些和DOM无关且耗时的任务（WebWorker还是在渲染进程中的）
* 避免强制同步布局。正常情况下在JS中通过DOMAPI进行操作时，是需要重新计算样式和布局的，但是这些操作都是在另外的任务中异步完成的，就是为了避免当前任务占用太长时间。强制同步布局就是指强制将这些任务提前到当前的任务中。比如在添加元素之后，立马要获取该元素的高度，这样就会触发强制同步布局
* 避免布局抖动。是指在一次JS执行过程中，多次执行强制布局
* 合理利用CSS处理动画（合成效率最高），另外可以用好will-change属性
* 避免频繁的垃圾回收。在一些函数中频繁创建临时对象，垃圾回收期也会频繁地去执行垃圾回收策略。应对策略就是尽可能优化存储结构，尽可能避免小颗粒对象的产生