## 同源策略

浏览器中有`同源策略`，同源的意思指`协议`，`端口`，`域名`都相同的网站，如果不符合这三者的话，就会出现以下限制

* DOM层面，不同站点无法获取DOM
* 数据层面，不同站点无法获取IndexDB，LocalStorage这样的数据
* 网络层面，Ajax或者Fetch无法向不同源网站发送请求/返回的结果被浏览器拦截

## 跨域的实现手段

同源策略一方面保护了网络传输的安全性，另一方面也限制了很多。对此浏览器做出了一些安全性和便利性的平衡，也就是我们平时说的跨域的解决策略

### 第三方资源的加载

HTML资源一般是通过HTTP请求获取到的，但是HTML解析过程中出现的资源则是在解析过程中下载或者执行的，这些资源的请求没有外域的限制

这么做的好处是比如JSONP这样的手段，坏处是比如XSS攻击（一个img标签里的是一段上传cookie的脚本）

### 跨域资源共享CORS

跨域资源共享(CORS)允许在HTTP响应头中加入字段让浏览器可以绕过跨域的限制，加载不同源资源。CORS的实现主要依靠服务端，也就是说`有没有CORS`纯粹看服务器会对你本次的请求作出什么样的响应

#### 简单请求和复杂请求

首先客户端发起的请求可以被分为简单请求和非简单请求，CORS对于这两种请求的作用机制是不一样的

简单请求的标准是

* 请求方法属于`GET`,`POST`,`HEAD`
* 请求头信息不能超过这几个字段`Accept`,`Accept-Language`,`Content-Language`,`Last-Event-ID`,`Content-Type`(application/x-www-form-urlencoded | multipart/form-data | text/plain)

#### 简单请求的机制

对于简单请求，浏览器直接发出CORS请求，即在头部加入`Orgin: xxxUrl`字段，表示本次请求来自哪个域（协议，域名，端口）

服务器根据该Origin请求头字段来决定是否予以CORS回应，回应的情况是在响应头中加入`Access-Control-Allow-Origin`，`Access-Control-Allow-Credentials`，`Access-Control-Expose-Headers`这三种字段

如果浏览器端接到了具有该字段的响应头，则表示CORS运行成功，如果返回的响应头没有的话，XHR对象会自动捕捉到错误并抛出错误，表示跨域失败

#### 复杂请求的机制

复杂请求一般的情况是特殊的请求方法或者特殊的请求类型比如json，如果客户端检测到本地请求属于复杂请求，会先使用OPTIONS方法进行一次`预检请求`，这个请求的目标是判定Origin是否被服务端允许，包含请求方法，请求头部和Origin信息

预检请求之后，就是和简单请求一样，普通请求时会带上Origin字段，服务端正常响应会带上Access-Control-Allow等三个字段，如果没有的话会抛出错误

### 跨文档消息机制

跨文档消息机制是H5之后引入的，主要应用场景是主页面和iframe页面进行通信的情况，正常情况下这两个页面之间属于不同源，会受到同源限制

我们可以通过postMessage和onMessage来进行消息传递

### JSONP

浏览器中存在同源策略，但是对DOM元素这种形式的引入不同源网站数据没有限制，要不然也不会有CDN缓存了。JSONP这是利用了这种策略,它通过插入标签的形式来实现跨域

```
// local
let script = document.createElement("script")
script.src = "url?callback=callback"
document.body.appendChild(script) // 加入HTML，开始下载和执行JS脚本

function callback(data) {
	let { name, age, title } = data
}

// remote

callback(data)
```

### 图像Ping

利用img标签的加载资源也不收跨域的限制的特性，主要用于埋点，比如统计一个页面中某个区域的点击次数。

* 只能发送GET请求
* 无法获取响应，只能表现为单方向通信


```
btn.onclick = () => {
	let img = document.createElement("img")
	img.onload = img.onerror = () => {
		// ...
	}
	img.src = "host?attr=value"
}

```

### WebSocket

### Comet




