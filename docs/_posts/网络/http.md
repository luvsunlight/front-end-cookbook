## CDN

CDN，即内容分发网络，它解决的是如何快速将数据从源站发送给用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的

在网站和用户之间引入CDN之后，用户不会有任何与原来不同的感觉。
使用CDN服务的网站，只需将其域名的解析权交给CDN的负载均衡设备，CDN负载均衡设备将为用户选择一台合适的缓存服务器，用户通过访问这台缓存服务器来获取自己所需的数据。
由于缓存服务器部署在网络运营商的机房，而这些运营商又是用户的网络服务提供商，因此用户可以以最短的路径，最快的速度对网站进行访问。因此，CDN可以加速用户访问速度，减少源站中心负载压力。

![](https://static001.geekbang.org/resource/image/91/c5/91c3e0a8f13ebc4d81f08d8604f770c5.png)

比如说，我们引入了CDN，原本使用单个TCP持久连接，下载100个资源，花费时间为`100 * n * RTT`,用了上述技术，可以把时间缩短为`100 * n * RTT / (6 * CDN个数)`

## HTTP是什么

HTTP是一种用于获取网络资源的通讯协议，是一种cs协议，通常是由像浏览器这样的b端发起的，它是基于TCP的应用层的协议（IP协议是网络层，TCP/UDP协议是传输层，HTTP是应用层）

### HTTP报文的组成

一个HTTP报文由三个部分组成

* 报文行
    * 请求
        * 请求方法
        * URL
        * 协议版本
    * 响应
        * 状态码
        * 状态信息
        * 协议版本
* 报文头
* 报文体

#### 请求方法

> GET。GET方法专门用来获取数据，它请求一个指定资源
> POST。POST方法用于将请求体提交给特定的资源
> HEAD。HEAD方法和GET方法一样请求一个指定资源，不过它的响应没有响应体，也就是说它的请求信息在头部
> DELETE
> CONNECT(管线化准备的请求方法)

#### 报文头

* Accept: 表示服务端能够接受的文件类型
* Cookie
* Referer: 从哪个网站过来的
* Cache-Control
* ETag:也是和缓存有关

#### 状态码

* 2XX(这个系列表示请求被正常响应了)
    * 200。最正常的结果，请求被正常响应了
    * 204 No Content。表示正常响应，但是没有响应体，一般用于客户端单方面向服务端发消息
* 3XX(这个系列表示请求被重定向了)
    * 301 Moved Permanently。永久重定向
    * 302 Found。临时重定向，以后的请求还是向这个url
    * 304 Not Modified。本地资源过期但是和服务端最新资源一样，属于协商缓存的一部分
    * 307 Temporary Redirect。可以理解成和临时重定向302一样，唯一的区别是307不允许浏览器将原本POST的请求重定向为GET请求、
* 4XX(这个系列表示客户端出错了)
    * 401 Bad Request。顾名思义，请求过程发生了错误
    * 402 Unauthorized。表示需要经过验证，若之前已经验证过了，则表示验证失败
    * 403 Forbidden。表示资源禁止被获取，可以不给出理由，如果要给的话可以放在响应体中
    * 404 Not Found。表示服务器找不到该资源
* 5XX(这个系列表示服务端出错了)
    * 500 Internet Server Error。表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障
    * 503 Service Unavilable。表示服务器暂时超负载或者停机维护，无法处理请求

## HTTP的特点

* 简单的
* 无状态的（可用cookie来解决）
* 可拓展的

## HTTP的发展史

> HTTP/0.9

* 最开始的HTTP协议，只被用来传输HTML
* 只有`请求行`

> HTTP/1.0

* 加入`请求头`
    * 数据类型
    * 压缩方法
    * 语言
    * 编码方式
* 增加状态码
* Cache，减轻服务器的压力

> HTTP/1.1

* 增加持久连接
* 不成熟的管线化
* 提供对虚拟主机的支持
* 客户端的Cookie

> HTTP/2

HTTP/1.1的缺点

* TCP慢启动
* TCP连接争抢带宽
* 队头阻塞

HTTP/2的改进

* 多路复用
* 二进制分帧，将传输的数据分成一帧一帧的，并且用二进制编码
* 服务端推送
* 头部压缩（分帧实现的）

> HTTP/3

HTTP/2的缺点

* 减少了TCP连接之间抢带宽的情况
* 减少TCP连接，也减少了慢启动
* 但还是存在对头阻塞，根本原因在于TCP连接本身的问题

HTTP/3

* 实现了类似TCP的流量控制，传输可靠的功能，UDP虽然不保证可靠的传输，但是QUIC在UDP的基础上增加了一层来保证数据可靠性传输
* 集成了TLS加密功能，并且减少了握手花费的RTT次数
* 实现了HTTP/2中的多路复用功能，它实现了在同一个物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题
* 实现了快速握手功能（减少了RTT的次数）

HTTP/3的挑战

* 缺少环境的支持
* 部署存在问题，因为系统内核对UDP的优化没有TCP的程度
* 中间设备僵化

## HTTPS







## 6. http缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当web缓存发现请求的资源已经被缓存了，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处是缓解服务端压力，提升性能（获取资源的耗时更短了），对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有的资源都是永久不变的，重要的是对一个资源的缓存应截止到其下一次发生改变

缓存的种类有很多，其大致可归为两类，私有和共享缓存，共享缓存存储的响应能够被多个用户使用。私有缓存只有用于单独用户

### 6.1 缓存操作的目标

虽然http缓存不是必须的,但是重用缓存的资源通常是必要的，然后常见的http缓存只能存储get响应，对于其他类型的响应则无能为力

### 6.2 缓存控制

#### 6.2.1 cache-control头

> 禁止缓存

`Cache-control: no-store`

> 强制确认缓存

每次有请求发出时，缓存会将次请求发送到服务器，服务器会验证请求中的缓存是否过期，如果没有过期则返回304，缓存使用本地缓存副本

`Cache-control: no-cache`

> 私有缓存和公共缓存

`public`指令表示该响应可以被任何中间人（比如中间代理，CDN等）缓存。若指定了public，则一些通常不被中间人缓存的页面（默认为private）（比如带有http验证信息账号密码验证信息的页面或者某些特定状态码的页面），将会被其缓存
 
而`private`表示该响应应该是专属于单个用户的，中间人不能缓存该响应

`Cache-control: private`
`Cache-control: public`

> 缓存过期机制

过期机制中，最重要的指令是`max-age=<seconds>`，表示资源能够被缓存的最大时间

`Cache-Control: max-age=31536000`

> 缓存验证确认

使用了`must-revalidate`指令时，意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已经过期的缓存将不能使用

#### 6.2.2 Prama头

Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端

#### 6.2.3 新鲜度

理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

![](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)


## 7. http Cookie

> http的cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一个服务器发送请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求会否来自同一浏览器，比如保持用户的登录状态。cookies是无状态的http协议记录稳定的状态信息成为了可能

cookie的主要功能

* 会话状态管理（用户登录状态，购物车，游戏分数或者其他需要记录的信息）
* 个性化设置
* 浏览器新闻跟踪

cookie曾一度用于客户端数据的存储，但是现在逐渐被淘汰。因为浏览器每次请求携带cookie会带来额外的性能开销。新的浏览器api已经允许开发者直接将数据存储到本地

### 7.1 创建cookie

当服务器收到http请求时，服务器可以在响应头里添加一个`Set-Cookie`选项，浏览器收到响应之后通常会保存下cookie，之后对该服务器的每一次请求中都通过cookie请求头部将cookie信息发送至服务器

`Set-Cookie: <cookie名>=<cookie值>`

### 7.2 会话期cookie

绘画器cookie是最简单的cookie，浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效，会话期cookie不需要指定过期时间（Expires）或者有效期（max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下，即使关闭了浏览器，会话期cookie也会被保留下来，就好像浏览器从来关闭一样

### 7.3 持久性cookie

可以指定一个特定的过期时间或者有效期

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`

### 7.4 cookie的作用域

`domain`和`path`标识定义了cookie的作用域，即cookie应该被发送给哪些url

domain一般自动包含子域名

### 7.5 js通过document.cookie访问cookie

## 8. http访问控制（CORS）

跨域资源共享是一种机制，它使用额外的http头来告诉浏览器，让运行在一个origin上的web应用被准许访问来自不同源服务器上指定的资源。当一个资源从与该资源本身所在的服务器不同的域，协议或者断就请求一个资源时，资源会发起一个跨域http请求

出于安全问题，浏览器限制从脚本发起的跨源http请求

### 8.1 什么情况下需要cors

* 跨域http请求
* web字体（@font-face），因此，网站就可以发布truetype字体资源，并只允许已授权网站进行跨站调用
* webGL贴图
* 使用drawImage将Images/video画面绘制canvas

## 9. 用法

[Mozilla web 安全引导](https://infosec.mozilla.org/guidelines/web_security)

> 一系列用于帮助运营团队创建安全的Web应用程序的提示






## 11. HTTPS

[参考《你连HTTPS 原理都不懂，还讲“中间人攻击”？》](https://mp.weixin.qq.com/s/TtxuUbqEpNV0en3-z37GBQ)

* 为什么用了https就是安全的
* https的底层原理如何实现
* 用了https就一定安全吗

> 我们可能听说，https协议之所以是安全的，是因为https会对传输的数据进行加密，而加密过程是使用了非对称加密实现，但其实https在内容传输的加密上用的是对称加密，非对称加密只用于证书验证阶段

### HTTPS的由来

HTTP协议被设计的目的很简单，就是为了传输超文本文件，并且也没有太强的加密，所以HTTP一直保持着明文传输的特征，但是这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，即`中间人攻击`

#### 在HTTP协议栈中引入安全层

![](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

在TCP和HTTP之间引入一个安全层，HTTP层先和安全层通信，然后安全层再和TCP层通信

安全层的主要职责有

* 对请求的数据进行加密
* 对接收的数据进行解密

#### HTTPS的特点

> 对称加密，即加密和解密都是同样的密钥

* 传输过程采用对称加密，但是对称加密的密钥采用非对称加密
    * 对称加密，密钥发送过程是明文的
    * 但是非对称加密效率太慢了
* 添加数字证书
    * 向浏览器证明服务器的身份
    * 数字证书里包含了服务器公钥
    * CA认证需要向专门的CA机构提交申请

### HTTPS传输过程

* 证书验证阶段
    * 浏览器发起HTTPS请求
    * 服务端返回HTTPS证书
    * 客户端验证证书是否合法，如果不合法则提示告警
* 数据传输阶段
    * 当证书验证合法后，在本地生成随机数
    * 通过公钥加密随机数，并把加密后的随机数传输到服务器
    * 服务端通过私钥对随机数进行解密
    * 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

### CA证书的必要性(中间人攻击)

中间人攻击的过程

* 本地请求被劫持（DNS劫持等），所有请求均发至中间人的服务器
中间人服务器返回中间人自己的证书
* 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
* 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
* 中间人以客户端的请求内容再向正规网站发起请求
* 正规网站通过建立安全的通道返回加密后的数据
* 中间人凭借与正规网站建立的对称加密算法对内容进行解密
* 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
* 客户端通过与中间人建立的对称加密算法对返回结果进行解密

说白了中间人攻击就是劫持DNS，然后让你在不知情的情况下抓你的包

这也就是https的好处，它在一开始就会验证传输对象的证书，能够最大程度地避免被抓包

但是它并不能完全避免抓包，比如即使浏览器提醒你该网站不安全，你依然选择点击，这种情况还是有被抓包的风险。如果用户主动授权，是可以构建中间人网络，比如代理软件，抓包软件



