## http概述

> http是一种能够获取如html这样的网络资源的**通讯协议**，是一种cs协议，也就是说，请求通常是由像浏览器这样的接收方发起的
> 
> http被设计于20世纪90年代初期，是一种可扩展的协议，它是**应用层**的协议，通过TCP，或者TLS-加密的TCP链接来访

![](https://mdn.mozillademos.org/files/13679/Client-server-chain.png)

实际上，在一个浏览器和处理请求的服务器之间，还有路由器，调制解调器等许多计算机，由于Web的层次设计，那些在网络层和传输层的细节都被隐藏了，http位于最上层的应用层，虽然底层对于分析网络问题非常重要，但是大多都和http的描述无关

### http的特点

* 简单的。http被设计成简单易堵的
* 可拓展
* 无状态，有会话的。http是无状态的，在同一个连接中，两次执行成功的请求之间是没有关系的，这就带来一个问题，用户无法在同一个网站中进行连续的交互。http cookies就可以解决这个问题。http本质是无状态的，cookies可以创建有状态的会话

### http能控制什么

* 缓存。服务端可以告诉代理哪些文档需要被缓存，缓存多久，而客户端也可以命令中间的缓存代理来忽略存储的文档
* 开放同源限制
* 认证。基本的认证功能可以直接通过http提供，使用`authenticate`或者`cookie`来设置指定的会话
* 代理和隧道。
* 会话

### http流

* 打开一个TCP链接，tcp连接被用来发送一条或者多条请求，以及接受响应消息，客户端可能打开一条新的链接，或者重用一个已经存在的连接
* 发送一个http报文

```
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```
* 读取服务端返回的报文信息

```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

* 关闭连接或者为后续请求重用连接

!> 当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。



## http报文

### 请求

![](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

* method
* path路径
* 版本协议号
* headers
* 发送的资源

### 响应

![](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

* http协议版本号
* 一个状态码
* 一个状态信息
* http headers
* 可选项

## http缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当web缓存发现请求的资源已经被缓存了，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处是缓解服务端压力，提升性能（获取资源的耗时更短了），对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有的资源都是永久不变的，重要的是对一个资源的缓存应截止到其下一次发生改变

缓存的种类有很多，其大致可归为两类，私有和共享缓存，共享缓存存储的响应能够被多个用户使用。私有缓存只有用于单独用户

### 缓存操作的目标

虽然http缓存不是必须的,但是重用缓存的资源通常是必要的，然后常见的http缓存只能存储get响应，对于其他类型的响应则无能为力

### 缓存控制

#### cache-control头

> 禁止缓存

`Cache-control: no-store`

> 强制确认缓存

每次有请求发出时，缓存会将次请求发送到服务器，服务器会验证请求中的缓存是否过期，如果没有过期则返回304，缓存使用本地缓存副本

`Cache-control: no-cache`

> 私有缓存和公共缓存

`public`指令表示该响应可以被任何中间人（比如中间代理，CDN等）缓存。若指定了public，则一些通常不被中间人缓存的页面（默认为private）（比如带有http验证信息账号密码验证信息的页面或者某些特定状态码的页面），将会被其缓存
 
而`private`表示该响应应该是专属于单个用户的，中间人不能缓存该响应

`Cache-control: private`
`Cache-control: public`

> 缓存过期机制

过期机制中，最重要的指令是`max-age=<seconds>`，表示资源能够被缓存的最大时间

`Cache-Control: max-age=31536000`

> 缓存验证确认

使用了`must-revalidate`指令时，意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已经过期的缓存将不能使用

#### Prama头

Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端

#### 新鲜度

理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

![](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)


## http Cookie

> http的cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一个服务器发送请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求会否来自同一浏览器，比如保持用户的登录状态。cookies是无状态的http协议记录稳定的状态信息成为了可能

cookie的主要功能

* 会话状态管理（用户登录状态，购物车，游戏分数或者其他需要记录的信息）
* 个性化设置
* 浏览器新闻跟踪

cookie曾一度用于客户端数据的存储，但是现在逐渐被淘汰。因为浏览器每次请求携带cookie会带来额外的性能开销。新的浏览器api已经允许开发者直接将数据存储到本地

### 创建cookie

当服务器收到http请求时，服务器可以在响应头里添加一个`Set-Cookie`选项，浏览器收到响应之后通常会保存下cookie，之后对该服务器的每一次请求中都通过cookie请求头部将cookie信息发送至服务器

`Set-Cookie: <cookie名>=<cookie值>`

### 会话期cookie

绘画器cookie是最简单的cookie，浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效，会话期cookie不需要指定过期时间（Expires）或者有效期（max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下，即使关闭了浏览器，会话期cookie也会被保留下来，就好像浏览器从来关闭一样

### 持久性cookie

可以指定一个特定的过期时间或者有效期

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`

### cookie的作用域

`domain`和`path`标识定义了cookie的作用域，即cookie应该被发送给哪些url

domain一般自动包含子域名

### js通过document.cookie访问cookie



## http访问控制（CORS）

## http的演变

## http的消息