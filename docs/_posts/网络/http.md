## 1. http概述

> http是一种能够获取如html这样的网络资源的**通讯协议**，是一种cs协议，也就是说，请求通常是由像浏览器这样的接收方发起的
> 
> http被设计于20世纪90年代初期，是一种可扩展的协议，它是**应用层**的协议，通过TCP，或者TLS-加密的TCP链接来访

![](https://mdn.mozillademos.org/files/13679/Client-server-chain.png)

实际上，在一个浏览器和处理请求的服务器之间，还有路由器，调制解调器等许多计算机，由于Web的层次设计，那些在网络层和传输层的细节都被隐藏了，http位于最上层的应用层，虽然底层对于分析网络问题非常重要，但是大多都和http的描述无关

### 2. http的特点

* 简单的。http被设计成简单易读的
* 可拓展
* 无状态，有会话的。http是无状态的，在同一个连接中，两次执行成功的请求之间是没有关系的，这就带来一个问题，用户无法在同一个网站中进行连续的交互。http cookies就可以解决这个问题。http本质是无状态的，cookies可以创建有状态的会话

### 3. http能控制什么

* 缓存。服务端可以告诉代理哪些文档需要被缓存，缓存多久，而客户端也可以命令中间的缓存代理来忽略存储的文档
* 开放同源限制
* 认证。基本的认证功能可以直接通过http提供，使用`authenticate`或者`cookie`来设置指定的会话
* 代理和隧道。
* 会话

### 4. http流

http(s)请求地址 => DNS解析 => 三次握手 => 发送请求 => 四次挥手

* 打开一个TCP链接，tcp连接被用来发送一条或者多条请求，以及接受响应消息，客户端可能打开一条新的链接，或者重用一个已经存在的连接
* 发送一个http报文

```
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```
* 读取服务端返回的报文信息

```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

* 关闭连接或者为后续请求重用连接

!> 当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。

## 5. http报文

### 5.1 请求

![](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

* method
* path路径
* 版本协议号
* headers
* 发送的资源

### 5.2 响应

![](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

* http协议版本号
* 一个状态码
* 一个状态信息
* http headers
* 可选项

## 6. http缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当web缓存发现请求的资源已经被缓存了，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处是缓解服务端压力，提升性能（获取资源的耗时更短了），对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有的资源都是永久不变的，重要的是对一个资源的缓存应截止到其下一次发生改变

缓存的种类有很多，其大致可归为两类，私有和共享缓存，共享缓存存储的响应能够被多个用户使用。私有缓存只有用于单独用户

### 6.1 缓存操作的目标

虽然http缓存不是必须的,但是重用缓存的资源通常是必要的，然后常见的http缓存只能存储get响应，对于其他类型的响应则无能为力

### 6.2 缓存控制

#### 6.2.1 cache-control头

> 禁止缓存

`Cache-control: no-store`

> 强制确认缓存

每次有请求发出时，缓存会将次请求发送到服务器，服务器会验证请求中的缓存是否过期，如果没有过期则返回304，缓存使用本地缓存副本

`Cache-control: no-cache`

> 私有缓存和公共缓存

`public`指令表示该响应可以被任何中间人（比如中间代理，CDN等）缓存。若指定了public，则一些通常不被中间人缓存的页面（默认为private）（比如带有http验证信息账号密码验证信息的页面或者某些特定状态码的页面），将会被其缓存
 
而`private`表示该响应应该是专属于单个用户的，中间人不能缓存该响应

`Cache-control: private`
`Cache-control: public`

> 缓存过期机制

过期机制中，最重要的指令是`max-age=<seconds>`，表示资源能够被缓存的最大时间

`Cache-Control: max-age=31536000`

> 缓存验证确认

使用了`must-revalidate`指令时，意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已经过期的缓存将不能使用

#### 6.2.2 Prama头

Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端

#### 6.2.3 新鲜度

理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

![](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)


## 7. http Cookie

> http的cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一个服务器发送请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求会否来自同一浏览器，比如保持用户的登录状态。cookies是无状态的http协议记录稳定的状态信息成为了可能

cookie的主要功能

* 会话状态管理（用户登录状态，购物车，游戏分数或者其他需要记录的信息）
* 个性化设置
* 浏览器新闻跟踪

cookie曾一度用于客户端数据的存储，但是现在逐渐被淘汰。因为浏览器每次请求携带cookie会带来额外的性能开销。新的浏览器api已经允许开发者直接将数据存储到本地

### 7.1 创建cookie

当服务器收到http请求时，服务器可以在响应头里添加一个`Set-Cookie`选项，浏览器收到响应之后通常会保存下cookie，之后对该服务器的每一次请求中都通过cookie请求头部将cookie信息发送至服务器

`Set-Cookie: <cookie名>=<cookie值>`

### 7.2 会话期cookie

绘画器cookie是最简单的cookie，浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效，会话期cookie不需要指定过期时间（Expires）或者有效期（max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下，即使关闭了浏览器，会话期cookie也会被保留下来，就好像浏览器从来关闭一样

### 7.3 持久性cookie

可以指定一个特定的过期时间或者有效期

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`

### 7.4 cookie的作用域

`domain`和`path`标识定义了cookie的作用域，即cookie应该被发送给哪些url

domain一般自动包含子域名

### 7.5 js通过document.cookie访问cookie

## 8. http访问控制（CORS）

跨域资源共享是一种机制，它使用额外的http头来告诉浏览器，让运行在一个origin上的web应用被准许访问来自不同源服务器上指定的资源。当一个资源从与该资源本身所在的服务器不同的域，协议或者断就请求一个资源时，资源会发起一个跨域http请求

出于安全问题，浏览器限制从脚本发起的跨源http请求

### 8.1 什么情况下需要cors

* 跨域http请求
* web字体（@font-face），因此，网站就可以发布truetype字体资源，并只允许已授权网站进行跨站调用
* webGL贴图
* 使用drawImage将Images/video画面绘制canvas

## 9. 用法

[Mozilla web 安全引导](https://infosec.mozilla.org/guidelines/web_security)

> 一系列用于帮助运营团队创建安全的Web应用程序的提示

## 10. http状态码

### 2xx

这个系列的状态码都表示请求被正常处理了

#### 200 OK

表示客户端发来的请求被正常处理了，这种情况一般是最“好”的结果

#### 204 No Content

表示服务器已成功处理请求，但是没有任何实体返回，页面不更新。一般用于客户端单方向向服务器发送信息

#### 206 Partical Content
表示客户端进行了[范围请求](#rangeRequest),而服务器成功执行了这个请求

### 3xx重定向

这个系列表示浏览器需要执行某些特殊的处理以正常处理请求

#### 301 Moved Permantly

永久性重定向，表示请求的资源已被分配了新的url，以后使用该资源时应该使用现在给的url（以报文首部的location字段里给出来了）

#### 302 Not Found

临时性重定向，希望用户本次能够使用新的url访问

#### 303 See Other

基本功能和302一致。但是明确向用户表示需要用GET方法获得资源

> 当301,302,303系列状态码发回时，几乎所有的浏览器都会把post改成GET，并且删除报文内的主体，之后请求会自动再次发送。当然这么做是有违标准的，但大家都会这么做

#### 304 Not Modified

表示客户端发送了附带条件的请求，服务器端找到了资源但是并未符合相应的条件

#### 307 Temporary Redirect

临时重定向，与302功能相似

### 4xx 客户端错误

该系列错误表示客户端是错误发生所在

#### 400 Bad Request

表示请求报文中存在语法错误。当错误发生时，需要修改内容并再次发送请求。

#### 401 Unauthorized

表示需要经过验证，若之前已经验证过了，则表示验证失败

#### 403 Forbidden

表示请求资源的访问被拒接了，服务器可以不给出理由，如果有理由，则可以在实体的主体部分中看到

#### 404 Not Found

服务器上没有请求的资源

### 5xx服务器错误

表示错误出在服务器上

#### 500 Internet Server Error

表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障

#### 503 Service Unavilable

表示服务器暂时超负载或者停机维护，无法处理请求

## 11. Https

[参考《你连HTTPS 原理都不懂，还讲“中间人攻击”？》](https://mp.weixin.qq.com/s/TtxuUbqEpNV0en3-z37GBQ)

* 为什么用了https就是安全的
* https的底层原理如何实现
* 用了https就一定安全吗

> 我们可能听说，https协议之所以是安全的，是因为https会对传输的数据进行加密，而加密过程是使用了非对称加密实现，但其实https在内容传输的加密上用的是对称加密，非对称加密只用于证书验证阶段

### https传输过程

* 证书验证阶段
    * 浏览器发起https请求
    * 服务端返回https证书
    * 客户端验证证书是否合法，如果不合法则提示告警
* 数据传输阶段
    * 当证书验证合法后，在本地生成随机数
    * 通过公钥加密随机数，并把加密后的随机数传输到服务器
    * 服务端通过私钥对随机数进行解密
    * 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

### 为什么数据传输是对称加密

首先，非对称加密的加解密效率十分低下，而http的应用场景中，通常端与端之间存在大量的交互，非对称加密的效率是无法接受的

此外，在https的场景下，客户端只有公钥，服务端才有私钥，只能实现单向的加解密，所以在内容传输的过程中，采用的是对称加密

### CA证书的必要性(中间人攻击)

中间人攻击的过程

* 本地请求被劫持（DNS劫持等），所有请求均发至中间人的服务器
中间人服务器返回中间人自己的证书
* 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
* 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
* 中间人以客户端的请求内容再向正规网站发起请求
* 正规网站通过建立安全的通道返回加密后的数据
* 中间人凭借与正规网站建立的对称加密算法对内容进行解密
* 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
* 客户端通过与中间人建立的对称加密算法对返回结果进行解密

说白了中间人攻击就是劫持DNS，然后让你在不知情的情况下抓你的包

这也就是https的好处，它在一开始就会验证传输对象的证书，能够最大程度地避免被抓包

但是它并不能完全避免抓包，比如即使浏览器提醒你该网站不安全，你依然选择点击，这种情况还是有被抓包的风险。如果用户主动授权，是可以构建中间人网络，比如代理软件，抓包软件
