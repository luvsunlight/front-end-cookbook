## CDN

CDN，即内容分发网络，它解决的是如何快速将数据从源站发送给用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的

在网站和用户之间引入CDN之后，用户不会有任何与原来不同的感觉。
使用CDN服务的网站，只需将其域名的解析权交给CDN的负载均衡设备，CDN负载均衡设备将为用户选择一台合适的缓存服务器，用户通过访问这台缓存服务器来获取自己所需的数据。
由于缓存服务器部署在网络运营商的机房，而这些运营商又是用户的网络服务提供商，因此用户可以以最短的路径，最快的速度对网站进行访问。因此，CDN可以加速用户访问速度，减少源站中心负载压力。

![](https://static001.geekbang.org/resource/image/91/c5/91c3e0a8f13ebc4d81f08d8604f770c5.png)

比如说，我们引入了CDN，原本使用单个TCP持久连接，下载100个资源，花费时间为`100 * n * RTT`,用了上述技术，可以把时间缩短为`100 * n * RTT / (6 * CDN个数)`

## HTTP是什么

### HTTP的定义

HTTP是一种用于获取网络资源的通讯协议，是一种cs协议，通常是由像浏览器这样的b端发起的，它是基于TCP的应用层的协议（IP协议是网络层，TCP/UDP协议是传输层，HTTP是应用层）

### HTTP报文的组成

一个HTTP报文由三个部分组成

* 报文行
    * 请求
        * 请求方法
        * URL
        * 协议版本
    * 响应
        * 状态码
        * 状态信息
        * 协议版本
* 报文头
* 报文体

#### 请求方法

> GET。GET方法专门用来获取数据，它请求一个指定资源
> POST。POST方法用于将请求体提交给特定的资源
> HEAD。HEAD方法和GET方法一样请求一个指定资源，不过它的响应没有响应体，也就是说它的请求信息在头部
> DELETE
> CONNECT(管线化准备的请求方法)

#### 报文头

* Accept: 表示服务端能够接受的文件类型
* Cookie
* Referer: 从哪个网站过来的
* Cache-Control
* ETag:也是和缓存有关

#### 状态码

* 2XX(这个系列表示请求被正常响应了)
    * 200。最正常的结果，请求被正常响应了
    * 204 No Content。表示正常响应，但是没有响应体，一般用于客户端单方面向服务端发消息
* 3XX(这个系列表示请求被重定向了)
    * 301 Moved Permanently。永久重定向
    * 302 Found。临时重定向，以后的请求还是向这个url
    * 304 Not Modified。本地资源过期但是和服务端最新资源一样，属于协商缓存的一部分
    * 307 Temporary Redirect。可以理解成和临时重定向302一样，唯一的区别是307不允许浏览器将原本POST的请求重定向为GET请求、
* 4XX(这个系列表示客户端出错了)
    * 401 Bad Request。顾名思义，请求过程发生了错误
    * 402 Unauthorized。表示需要经过验证，若之前已经验证过了，则表示验证失败
    * 403 Forbidden。表示资源禁止被获取，可以不给出理由，如果要给的话可以放在响应体中
    * 404 Not Found。表示服务器找不到该资源
* 5XX(这个系列表示服务端出错了)
    * 500 Internet Server Error。表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障
    * 503 Service Unavilable。表示服务器暂时超负载或者停机维护，无法处理请求

## HTTP的特点

* 简单的
* 无状态的（可用cookie来解决）
* 可拓展的

## HTTP缓存

缓存是一种保存资源副本，下次发起相同请求时直接复用的技术，是减轻服务器压力和增加客户端下载速度的手段

### 缓存的资源目标

* 成功的GET请求（这意味着只有直接请求的HTML资源或者Ajax手段请求的数据才会被缓存，像CDN这样的不会被缓存的）
* 永久重定向301
* 错误响应404

### 缓存的分类

根据一个HTTP请求流程中的情况不同，HTTP请求过程中出现的缓存可以分为强缓存（本地缓存）和协商缓存（弱缓存）

![](https://segmentfault.com/img/bVuuo2)

浏览器在发起HTTP请求时，如果该请求属于`缓存的资源目标`（GET请求，301，404）,则首先在本地寻找有没有对应的缓存副本，如果有，看其有没有过期，这个过程称之为`强缓存`.强缓存受`Cache-Control`响应头和`Expires`响应头控制。如果该资源存在但是在强缓存中被判定为过期，则进行下一步

首先，一份资源服务器在发送给客户端时有时会带上ETag，这是一种强校验器，相当于这份资源的`身份证`，如果该缓存的header中有ETag，则会在向服务器的请求中带上`If-None-Match`字段，如果没有ETag没有关系，正常情况下服务器还会在资源的响应头中加入Last-Modified字段

普通刷新会忽略强缓存，但是并不会清除强缓存。它的机制是在请求头中加入`Cache-Control:no-cache`和`pragam:no-cache`

正常页面直接刷新的话也是忽略强缓存，强缓存只有在重新输入URL等链接时才会启用

### 强缓存的控制

#### Cache-Control

这个报文头在请求和响应里都有

* no-store。禁止进行缓存
* no-cache。没有强缓存，每次都进行协商缓存，即不管本地缓存有没有过期，都要向服务器发GET请求，直到返回304
* public。表示该请求可以被任何中间人（CDN，中间代理）缓存
* private。默认是private，表示返回的响应是单属于某个用户的
* max-age=<seconds>。表示该响应的资源可以被缓存的最大周期

#### Expires

这个报文头包含日期和时间，含义是在这个时间之后，该资源无效。如果和Cache-Control:max-age冲突，则会被覆盖掉

### 协商缓存的控制

#### ETag和If-None-Match

ETag是一种对资源的强校验器，相当于资源的身份证，如果浏览器发现该缓存资源的header中存在ETag，就会在请求头中加入If-None-Match字段，以看服务器端的资源有没有更新

#### Last-Modified和If-Modified-since

Last-Modified同样是一种验证资源过期的手段，顾名思义，Last-Modified就是这份资源上次修改的时间，如果请求中带上的Last-Modified和服务端资源的一样，服务端就会返回304NotModified

Last-Modified是一种弱校验器，因为它时间精度差，而且在服务端一个文件可能经常修改，但是内容不变，如果Last-Modified和ETag同时存在，则采用ETag

## Cookie

### Cookie是什么

> Cookie是一种服务器发送给客户端用于唯一表示客户端的标识符。它的工作流程如下，客户端向服务端发送请求，服务端在响应头中加入Set-Cookie字段，客户端收到响应后会将此Cookie字段保留下来，一方面本地可以访问，另一方面，之后每次HTTP请求都会带上此Cookie

### Cookie的应用

* 会话管理，比如登录状态等
* 个性设置，比如密码或者个性设置
* 浏览器行为跟踪

### Cookie的分类

根据作用，Cookie可以简单分为会话期Cookie和持久Cookie。会话期Cookie在会话关闭时（TCP连接断开时）就会消失，而持久型Cookie用于比如个性设置等，可以设置Expires值来确保其生存周期

### Cookie的特性

* 可以被DOMAPI获取，我们可以通过document.cookie获取目前域的cookie
* 鉴于Cookie的原理，它实际上是和一个域绑定的
* Secure标记。有了Secure标记的cookie只能被HTTPS协议加密过的请求发送
* HTTPOnly标记。正常情况下Cookie是可以被DOMAPI获取的，加了这个标记的Cookie只能在每次HTTP请求时自动带上
* Domain和Path属性。指定了Cookie只能发给哪些域以及域名下的什么路径
* Samesite属性，可以指定为`None`,`Strict`，`Lax`，指的是Cookie只能发送给Cookie本身绑定的那个域的域名，Lax是会保留一些子域名

### Cookie和Session

要明确的是Session是一种理念，Cookie是实实在在的数据。Session的目的是为了解决HTTP无状态的问题。我们已经知道Cookie是服务端发送给客户端并且存储在客户端的数据，相当于客户端的身份证号，但是服务端这边也需要一个身份证号验证系统来判断该身份证号是否合法和存在。Cookie是Session的一种很好的解决办法，当然没有Cookie也可以，比如在URL后面加入一个SID，Session的核心就是SId，通常这个数据是借助Cookie实现的而已

* Session是概念，Cookie是数据
* Cookie存储在本地，Session的实现存储在服务器
* Session的实现很多情况借助Cookie实现，但是没有也可以

## HTTP的发展史

> HTTP/0.9

* 最开始的HTTP协议，只被用来传输HTML
* 只有`请求行`

> HTTP/1.0

* 加入`请求头`
    * 数据类型
    * 压缩方法
    * 语言
    * 编码方式
* 增加状态码
* Cache，减轻服务器的压力

> HTTP/1.1

* 增加持久连接
* 不成熟的管线化
* 提供对虚拟主机的支持
* 客户端的Cookie

> HTTP/2

HTTP/1.1的缺点

* TCP慢启动
* TCP连接争抢带宽
* 队头阻塞

HTTP/2的改进

* 多路复用
* 二进制分帧，将传输的数据分成一帧一帧的，并且用二进制编码
* 服务端推送
* 头部压缩（分帧实现的）

> HTTP/3

HTTP/2的缺点

* 减少了TCP连接之间抢带宽的情况
* 减少TCP连接，也减少了慢启动
* 但还是存在对头阻塞，根本原因在于TCP连接本身的问题

HTTP/3

* 实现了类似TCP的流量控制，传输可靠的功能，UDP虽然不保证可靠的传输，但是QUIC在UDP的基础上增加了一层来保证数据可靠性传输
* 集成了TLS加密功能，并且减少了握手花费的RTT次数
* 实现了HTTP/2中的多路复用功能，它实现了在同一个物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题
* 实现了快速握手功能（减少了RTT的次数）

HTTP/3的挑战

* 缺少环境的支持
* 部署存在问题，因为系统内核对UDP的优化没有TCP的程度
* 中间设备僵化

## HTTPS

### HTTP的缺点

* 明文传输，丢包数据泄露很严重 => 抓包
* 消息完整性检测（内容是否被篡改没有相应防御措施）=> 中间人攻击

### HTTPS的定义

HTTPS就是为了解决HTTP最大的这两个安全问题而设计出来的网络通信协议，它在HTTP的基础上加入了一个安全层（SSL层），同时在建立连接时还需要进行证书验证

### HTTPS的原理

* 客户端构造c_secret,以及自己这边支持的加密算法（当然还有一些细节比如数字签名等等）
* 服务端收到请求，构造s_secret，返回s_secret，采用的加密算法，一般是安全性最高的,以及自己的证书（包含非对称加密的公钥）
* 客户端收到证书，开始验证证书，如果合规则继续连接，否则会给出提醒，当然用户可以自行选择是否继续连接。如果继续连接则客户端使用证书中的公钥，构建一个pre-master-secret并且加密传输给服务端
* 服务端收到了该预主密钥，用自己的私钥进行解密

### 证书

### 对称加密和非对称加密

### 中间人攻击



## WebSocket













## 8. http访问控制（CORS）

跨域资源共享是一种机制，它使用额外的http头来告诉浏览器，让运行在一个origin上的web应用被准许访问来自不同源服务器上指定的资源。当一个资源从与该资源本身所在的服务器不同的域，协议或者断就请求一个资源时，资源会发起一个跨域http请求

出于安全问题，浏览器限制从脚本发起的跨源http请求

### 8.1 什么情况下需要cors

* 跨域http请求
* web字体（@font-face），因此，网站就可以发布truetype字体资源，并只允许已授权网站进行跨站调用
* webGL贴图
* 使用drawImage将Images/video画面绘制canvas

## 9. 用法

[Mozilla web 安全引导](https://infosec.mozilla.org/guidelines/web_security)

> 一系列用于帮助运营团队创建安全的Web应用程序的提示









#### HTTPS的特点

> 对称加密，即加密和解密都是同样的密钥

* 传输过程采用对称加密，但是对称加密的密钥采用非对称加密
    * 对称加密，密钥发送过程是明文的
    * 但是非对称加密效率太慢了
* 添加数字证书
    * 向浏览器证明服务器的身份
    * 数字证书里包含了服务器公钥
    * CA认证需要向专门的CA机构提交申请

### HTTPS传输过程

* 证书验证阶段
    * 浏览器发起HTTPS请求
    * 服务端返回HTTPS证书
    * 客户端验证证书是否合法，如果不合法则提示告警
* 数据传输阶段
    * 当证书验证合法后，在本地生成随机数
    * 通过公钥加密随机数，并把加密后的随机数传输到服务器
    * 服务端通过私钥对随机数进行解密
    * 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

### CA证书的必要性(中间人攻击)

中间人攻击的过程

* 本地请求被劫持（DNS劫持等），所有请求均发至中间人的服务器
中间人服务器返回中间人自己的证书
* 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
* 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
* 中间人以客户端的请求内容再向正规网站发起请求
* 正规网站通过建立安全的通道返回加密后的数据
* 中间人凭借与正规网站建立的对称加密算法对内容进行解密
* 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
* 客户端通过与中间人建立的对称加密算法对返回结果进行解密

说白了中间人攻击就是劫持DNS，然后让你在不知情的情况下抓你的包

这也就是https的好处，它在一开始就会验证传输对象的证书，能够最大程度地避免被抓包

但是它并不能完全避免抓包，比如即使浏览器提醒你该网站不安全，你依然选择点击，这种情况还是有被抓包的风险。如果用户主动授权，是可以构建中间人网络，比如代理软件，抓包软件



