## CDN

CDN，即内容分发网络，它解决的是如何快速将数据从源站发送给用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的

在网站和用户之间引入CDN之后，用户不会有任何与原来不同的感觉。
使用CDN服务的网站，只需将其域名的解析权交给CDN的负载均衡设备，CDN负载均衡设备将为用户选择一台合适的缓存服务器，用户通过访问这台缓存服务器来获取自己所需的数据。
由于缓存服务器部署在网络运营商的机房，而这些运营商又是用户的网络服务提供商，因此用户可以以最短的路径，最快的速度对网站进行访问。因此，CDN可以加速用户访问速度，减少源站中心负载压力。

![](https://static001.geekbang.org/resource/image/91/c5/91c3e0a8f13ebc4d81f08d8604f770c5.png)

一个最简单的CDN模型可能是这样的

* CDN网络由一个DNS服务器和多个缓存服务器组成
* 用户url解析的DNS请求发送到了DNS服务器上
* DNS服务器把CDN的全局负载均衡设备的ip发送给用户
* 用户再访问全局负载均衡设备
* 该设备通过用户的ip地址和请求内容，查看离用户最接近，且拥有用户请求的资源的缓存服务器，将这个服务器的ip地址发送给用户
* 用户收到ip后，再和这个ip代表的缓存服务器进行通信，并且进行资源的传输

可以看出来CDN网络的优势在于

* 减轻源站的负载压力
* 提高用户获取资源的效率

## HTTP是什么

### HTTP的定义

HTTP是一种用于获取网络资源的通讯协议，是一种cs协议，通常是由像浏览器这样的b端发起的，它是基于TCP的应用层的协议（IP协议是网络层，TCP/UDP协议是传输层，HTTP是应用层）

### HTTP报文的组成

一个HTTP报文由三个部分组成

* 报文行
    * 请求
        * 请求方法
        * URL
        * 协议版本
    * 响应
        * 状态码
        * 状态信息
        * 协议版本
* 报文头
* 报文体

#### 请求方法

> GET。GET方法专门用来获取数据，它请求一个指定资源
> POST。POST方法用于将请求体提交给特定的资源
> HEAD。HEAD方法和GET方法一样请求一个指定资源，不过它的响应没有响应体，也就是说它的请求信息在头部
> DELETE
> CONNECT(管线化准备的请求方法)

#### 报文头

* Accept: 表示服务端能够接受的文件类型
* Cookie
* Referer: 从哪个网站过来的
* Cache-Control
* ETag:也是和缓存有关

#### 状态码

* 2XX(这个系列表示请求被正常响应了)
    * 200。最正常的结果，请求被正常响应了
    * 204 No Content。表示正常响应，但是没有响应体，一般用于客户端单方面向服务端发消息
* 3XX(这个系列表示请求被重定向了)
    * 301 Moved Permanently。永久重定向
    * 302 Found。临时重定向，以后的请求还是向这个url
    * 304 Not Modified。本地资源过期但是和服务端最新资源一样，属于协商缓存的一部分
    * 307 Temporary Redirect。可以理解成和临时重定向302一样，唯一的区别是307不允许浏览器将原本POST的请求重定向为GET请求、
* 4XX(这个系列表示客户端出错了)
    * 401 Bad Request。顾名思义，请求过程发生了错误
    * 402 Unauthorized。表示需要经过验证，若之前已经验证过了，则表示验证失败
    * 403 Forbidden。表示资源禁止被获取，可以不给出理由，如果要给的话可以放在响应体中
    * 404 Not Found。表示服务器找不到该资源
* 5XX(这个系列表示服务端出错了)
    * 500 Internet Server Error。表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障
    * 503 Service Unavilable。表示服务器暂时超负载或者停机维护，无法处理请求

## HTTP的特点

* 简单的
* 无状态的（可用cookie来解决）
* 可拓展的

## HTTP缓存

缓存是一种保存资源副本，下次发起相同请求时直接复用的技术，是减轻服务器压力和增加客户端下载速度的手段

### 缓存的资源目标

* 成功的GET请求（这意味着只有直接请求的HTML资源或者Ajax手段请求的数据才会被缓存，像CDN这样的不会被缓存的）
* 永久重定向301
* 错误响应404

### 缓存的分类

根据一个HTTP请求流程中的情况不同，HTTP请求过程中出现的缓存可以分为强缓存（本地缓存）和协商缓存（弱缓存）

![](https://segmentfault.com/img/bVuuo2)

浏览器在发起HTTP请求时，如果该请求属于`缓存的资源目标`（GET请求，301，404）,则首先在本地寻找有没有对应的缓存副本，如果有，看其有没有过期，这个过程称之为`强缓存`.强缓存受`Cache-Control`响应头和`Expires`响应头控制。如果该资源存在但是在强缓存中被判定为过期，则进行下一步

首先，一份资源服务器在发送给客户端时有时会带上ETag，这是一种强校验器，相当于这份资源的`身份证`，如果该缓存的header中有ETag，则会在向服务器的请求中带上`If-None-Match`字段，如果没有ETag没有关系，正常情况下服务器还会在资源的响应头中加入Last-Modified字段

普通刷新会忽略强缓存，但是并不会清除强缓存。它的机制是在请求头中加入`Cache-Control:no-cache`和`pragam:no-cache`

正常页面直接刷新的话也是忽略强缓存，强缓存只有在重新输入URL等链接时才会启用

### 强缓存的控制

#### Cache-Control

这个报文头在请求和响应里都有

* no-store。禁止进行缓存
* no-cache。没有强缓存，每次都进行协商缓存，即不管本地缓存有没有过期，都要向服务器发GET请求，直到返回304
* public。表示该请求可以被任何中间人（CDN，中间代理）缓存
* private。默认是private，表示返回的响应是单属于某个用户的
* max-age=<seconds>。表示该响应的资源可以被缓存的最大周期

#### Expires

这个报文头包含日期和时间，含义是在这个时间之后，该资源无效。如果和Cache-Control:max-age冲突，则会被覆盖掉

### 协商缓存的控制

#### ETag和If-None-Match

ETag是一种对资源的强校验器，相当于资源的身份证，如果浏览器发现该缓存资源的header中存在ETag，就会在请求头中加入If-None-Match字段，以看服务器端的资源有没有更新

#### Last-Modified和If-Modified-since

Last-Modified同样是一种验证资源过期的手段，顾名思义，Last-Modified就是这份资源上次修改的时间，如果请求中带上的Last-Modified和服务端资源的一样，服务端就会返回304NotModified

Last-Modified是一种弱校验器，因为它时间精度差，而且在服务端一个文件可能经常修改，但是内容不变，如果Last-Modified和ETag同时存在，则采用ETag

## Cookie

### Cookie是什么

> Cookie是一种服务器发送给客户端用于唯一表示客户端的标识符。它的工作流程如下，客户端向服务端发送请求，服务端在响应头中加入Set-Cookie字段，客户端收到响应后会将此Cookie字段保留下来，一方面本地可以访问，另一方面，之后每次HTTP请求都会带上此Cookie

### Cookie的应用

* 会话管理，比如登录状态等
* 个性设置，比如密码或者个性设置
* 浏览器行为跟踪

### Cookie的分类

根据作用，Cookie可以简单分为会话期Cookie和持久Cookie。会话期Cookie在会话关闭时（TCP连接断开时）就会消失，而持久型Cookie用于比如个性设置等，可以设置Expires值来确保其生存周期

### Cookie的特性

* 可以被DOMAPI获取，我们可以通过document.cookie获取目前域的cookie
* 鉴于Cookie的原理，它实际上是和一个域绑定的
* Secure标记。有了Secure标记的cookie只能被HTTPS协议加密过的请求发送
* HTTPOnly标记。正常情况下Cookie是可以被DOMAPI获取的，加了这个标记的Cookie只能在每次HTTP请求时自动带上
* Domain和Path属性。指定了Cookie只能发给哪些域以及域名下的什么路径
* Samesite属性，可以指定为`None`,`Strict`，`Lax`，指的是Cookie只能发送给Cookie本身绑定的那个域的域名，Lax是会保留一些子域名

### Cookie和Session

要明确的是Session是一种理念，Cookie是实实在在的数据。Session的目的是为了解决HTTP无状态的问题。我们已经知道Cookie是服务端发送给客户端并且存储在客户端的数据，相当于客户端的身份证号，但是服务端这边也需要一个身份证号验证系统来判断该身份证号是否合法和存在。Cookie是Session的一种很好的解决办法，当然没有Cookie也可以，比如在URL后面加入一个SID，Session的核心就是SId，通常这个数据是借助Cookie实现的而已

* Session是概念，Cookie是数据
* Cookie存储在本地，Session的实现存储在服务器
* Session的实现很多情况借助Cookie实现，但是没有也可以

## HTTP的发展史

> HTTP/0.9

* 最开始的HTTP协议，只被用来传输HTML
* 只有`请求行`

> HTTP/1.0

* 加入`请求头`
    * 数据类型
    * 压缩方法
    * 语言
    * 编码方式
* 增加状态码
* Cache，减轻服务器的压力

> HTTP/1.1

* 增加持久连接
* 不成熟的管线化
* 提供对虚拟主机的支持
* 客户端的Cookie

> HTTP/2

HTTP/1.1的缺点

* TCP慢启动
* TCP连接争抢带宽
* 队头阻塞

HTTP/2的改进

* 多路复用
* 二进制分帧，将传输的数据分成一帧一帧的，并且用二进制编码
* 服务端推送
* 头部压缩（分帧实现的）

> HTTP/3

HTTP/2的缺点

* 减少了TCP连接之间抢带宽的情况
* 减少TCP连接，也减少了慢启动
* 但还是存在对头阻塞，根本原因在于TCP连接本身的问题

HTTP/3

* 实现了类似TCP的流量控制，传输可靠的功能，UDP虽然不保证可靠的传输，但是QUIC在UDP的基础上增加了一层来保证数据可靠性传输
* 集成了TLS加密功能，并且减少了握手花费的RTT次数
* 实现了HTTP/2中的多路复用功能，它实现了在同一个物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题
* 实现了快速握手功能（减少了RTT的次数）

HTTP/3的挑战

* 缺少环境的支持
* 部署存在问题，因为系统内核对UDP的优化没有TCP的程度
* 中间设备僵化

## HTTPS

### HTTP的缺点

* 明文传输，丢包数据泄露很严重 => 抓包
* 消息完整性检测（内容是否被篡改没有相应防御措施）=> 中间人攻击

### HTTPS的定义

HTTPS就是为了解决HTTP最大的这两个安全问题而设计出来的网络通信协议，它在HTTP的基础上加入了一个安全层（SSL层），同时在建立连接时还需要进行证书验证

### HTTPS的原理

* 客户端构造c_secret,以及自己这边支持的加密算法（当然还有一些细节比如数字签名等等）
* 服务端收到请求，构造s_secret，返回s_secret，采用的加密算法，一般是安全性最高的,以及自己的证书（包含非对称加密的公钥）
* 客户端收到证书，开始验证证书，如果合规则继续连接，否则会给出提醒，当然用户可以自行选择是否继续连接。如果继续连接则客户端使用证书中的公钥，构建一个pre-master-secret并且加密传输给服务端
* 服务端收到了该预主密钥，用自己的私钥进行解密,此时客户端和服务端都收到了三个密钥，以及公钥，两端可以利用公钥对这三个密钥进行加密，形成主密钥
* 此后的HTTPS通信，将以此主密钥进行对称加密

### 证书

证书是防止中间人攻击的手段，它本质上是一个认证信息。包括

* 证书信息（过期时间和序列号）
* 所有者信息（服务器域名）
* 公钥
* 数字签名

一般证书我们可以自己制作，但是这样的证书不被得到承认，只有被权威机构CA认证的证书才会在校验过程中被认定为合法

证书验证的流程如下

* 服务器端
    * 证书信息hash化变成信息摘要
    * 信息摘要经过CA私钥加密，变成数字签名
* 客户端
    * 解密证书后可以获取数字签名和信息摘要
    * 使用CA的公钥对数字签名解密，再和信息摘要对比，如果相同则表示整数确实由CA颁发，没有经过篡改

### 中间人攻击

中间人即客户端和服务器之间通信的中介，我们以HTTP通信为例，讲一下中间人攻击的原理。比如本地请求被劫持，先经过中间人服务器，三次握手建立连接之后，每次客户端和服务器的包都会经过中间人服务器，尤其是HTTP还是明文传输的，更为危险，对于HTTPS，也可以存在中间人攻击

### 对称加密和非对称加密

加密过程分为对称加密和非对称加密，对称加密指用同一个密钥加密和解密，非对称指存在公钥和私钥

对称加密隐秘性低，因为一旦被破解公钥通信就透明了，但是非对称加密效率低，因为其解密效率慢

### 为什么要预主密钥

可以看出来c_secret和s_secret都是处于明文传输的状态，都是可以被中间人截取的，只有预主密钥才是被加密的，这是为了

### HTTPS的特点

优点是

* 内容安全性保证
* 加密传输

缺点
* 证书费用
* HTTPS增加了额外的通信成本
* 加密范围有限
* CA不一定牢靠

## WebSocket

### Web Socket是什么

这也是一种单独的网络协议，它和HTTP一样是基于TCP的。是为了解决HTTP协议只能单向通信而出现的(服务端推送)。TCP协议是支持双向交流的，但是HTTP不是，它是一种典型的c/s协议，只允许`请求-响应`这样的模式。像我们如果要实现实时游戏的话，以前的做法是轮询或者Comet，但是这么做让服务器挂起很影响效率。WS应运而生

### WS的特点

* 双向通信
* 数据小
* 可以发送文本，可以发送二进制文件
* 没有同源限制
* 需要服务端支持
* 需要一次HTTP通信来进行握手
    * URL变化
    * 请求头
        * Upgrade:Web Socket
        * Connection: Web Socket















