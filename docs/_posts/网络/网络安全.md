!> 当机器处于不安全环境时，切记不能通过http cookie存储和传输敏感信息

## 同源策略

如果两个URL的`协议`，`域名`，`端口`都相同，我们就称这两个URL同源。两个不同的源之间若是想相互访问资源或者操作DOM，那么就会有一套基础的安全策略的制约，我们称之为同源策略

同源策略的限制体现在

* DOM层面。不同源的站点无法获取和操作当前站点的DOM
* 数据层面。不同源的站点无法获取当前站点的Cookie，IndexDB,LocalStorage
* 网络层面。限制了通过XHR将站点的数据发送给不同源的站点

### 安全性和便利性的权衡

安全性和便利性是相互对立的，绝对的网络安全也带来绝对的通信不便利，浏览器也在便利性上出让了一些安全性

#### 页面中可以嵌入第三方资源

对于HTML中的资源，最初浏览器都是支持外部引用资源文件的，不过这也带来了很多问题，比如恶意程序可以`通过任意手段往HTML中插入第三方资源形式的JS文件`，注入之后，恶意脚本就寄生在页面之中，当用户启动该页面时，就可以进行各种操作如窃取信息等

以上就是一个典型的XSS攻击，为了解决XSS攻击，浏览器引入了内容安全策略，即CSP，CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JS代码

#### 跨域资源贡献和跨文档消息机制

两个不同源的网站相互XHR通信是会block的，为了解决这个问题，我们引入了`跨域资源共享（CORS）`

同源策略会限制不同源的DOM，数据和网路通信，但是实际应用中，经常需要两个不同源的DOM之间通信，于是浏览器引入了`跨文档消息机制`，通过window.postMessage来和不同源的DOM进行通信

## 内容安全策略（CSP）

[MDN上的CSP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)

内容安全策略（CSP,Content Security Policy）是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本

### CSP的实现

以下方法二选一

* 服务端设置HTTP响应头`Content-Security-Policy: policy`
* 浏览器端设置meta元素`Content-Security-Policy: policy`

### CSP的功能

* 指定有效域
* 指定有效数据类型
* 指定通信协议
* 指定单独JS脚本不能加载来自外域的

## SQL注入

SQL注入的原理是前端在输入时进行了恶意的SQL拼装，那么最后生成的SQL就会有问题，但是现在基本稍微大型一点的系统都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证，基本上这个只会出现在比较低端小型的系统上

## XSS

### XSS的定义

跨站脚本攻击XSS(Cross site scripting)，恶意攻击者往web页面中插入恶意js代码，当用户浏览该页面时，嵌入其中的js代码会被执行，从而达到恶意攻击用户的目的

比如说我们再一个博客网站上写博客，如果是正常的博客形式那完全没有问题，可如果我们撰写的是恶意的js脚本，例如获取到document.cookie然后传输到我自己的服务器上，那么我在博客网站上发布的这篇文章每被别人浏览一次，这段代码就被执行一次，访客的信息就会被泄露。

总结就是黑客通过发布文章/评论，将一段特定的js代码隐蔽地输入进去，然后别人再看这篇文章或者评论时，这段代码就执行了，这些恶意底阿妈拥有和原网页一样的权限

### XSS的原理

* 攻击者对含有漏洞的服务器发起XSS攻击（注入js代码）
* 诱使受害者打开攻击的服务器url
* 受害者在web浏览器中打开url，恶意脚本执行

### XSS的攻击方式

#### 反射型

发出请求时，xss代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，xss随着响应内容一起返回给浏览器，最后浏览器解析执行xss代码

#### 存储型

存储型xss和反射型的xss差别就在于，存储型的xss提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求页面时不用再提交xss代码.反射型的XSS攻击，Web服务器不会存储其恶意脚本

#### 基于DOM的XSS攻击

这类型的XSS攻击是不牵涉页面Web服务器的，比如通过各种手段将恶意脚本注入到用户的页面中，比如通过路由器劫持，然后在Web资源传输过程或者在用户使用页面的过程中修改Web页面的数据

### XSS的防御措施

* 编码，对用户输入的数据进行html entity编码

![](https://img-blog.csdn.net/20170418160547231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FueWluZ3hpZTEyMzQ1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 过滤，移除用户上传的dom属性，如onerror，移除用户上传的style节点，script节点，iframe节点等
* 校正，避免直接对html entity编码，使用DOMparse转换，校正不配对的dom标签
* 对cookie进行较强的限制，比如对敏感的cookie增加http-only限制。该标记的Cookie只能用于HTTP请求，无法被JS获取
* 充分利用CSP
    * 限制加载其他域下的资源文件
    * 禁止向第三方域提交数据
    * 禁止执行内联脚本和未授权的脚本

### XSS的常见表现形式

img标签是自动触发而受到攻击的，p标签是引诱触发而遭到攻击的，而iframe是广告植入攻击的

## 跨站请求伪造（CSRF）

Cross-site request forery跨站请求伪造，CSRF是借用了当前操作者的权限来偷偷完成该操作，而不是拿到用户的信息。

比如一个支付网站，付账的接口不需要密码，只要访问对应的url就可以完成付账，然后假如一个用户登陆了该网站，然后收到了一封邮件，打开该邮件，就通过img标签中的url完成了付款界面。它这里是利用了共享cookie的特性

和XSS不同的是，CSRF不需要获取用户的信息，它只需要借助用户目前的登录状态Cookie，然后来完成一些有害操作

预防CSRF就是加入各个层级的验证，比如输密码或指纹等

### CSRF的防御措施

* 利用好Cookie的Samesite属性
* 验证请求的来源站点，通过Origin属性和Referer值
* 加上额外的验证层，比如CSRF Token

## Refer

* [Web安全之XSS攻防](https://blog.csdn.net/ganyingxie123456/article/details/70230486)

