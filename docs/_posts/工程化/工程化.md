## 1. 定义

前端工程化

* 工具链
    * [模块化](/_posts/工程化/模块化)
        * [webpack](/_posts/工程化/webpack)
        * [rollup](/_posts/工程化/rollup)
    * [构建工具](/_posts/工程化/构建工具)
        * [gulp](/_posts/工程化/gulp)
        * grunt
    * [包管理工具]()
        * [npm](/_posts/工程化/npm)
        * yarn
        * bower
    * 版本管理
        * [git](/_posts/工程化/git)
        * svn
    * [脚手架](/_posts/工程化/脚手架)
    * [i18n](/_posts/工程化/本地化和国际化)
* [持续集成](/_posts/工程化/持续集成)
* [PWA](/_posts/工程化/PWA)


## 2. 工具体系的目标

工具体系并非是业务结果，它结果更多是一种开发体验：帮助技术团队的人提升效率和体验

作为工程体系，我们考虑工具的同时同样也要遵循基本规则现状和指标，方案，实施，结果和监控

不过，对于工具而言，指标和结果都是一种软性指标，也就是团队的开发效率和开发体验，不适合过度数据化

假如你是一个前端团队的工具体系负责人，现在要你来规划团队的工具体系，你会怎么做呢

如果只是在社区里找到了一大堆工具并且对它们的职责范围一一罗列出来，作为工具体系的目标，那么就是完全走上了错误的道路

在考虑具体的工具之前，我们应该解决工具体系的元问题，即我们对工具体系本身的要求是什么

至少，我们要满足如下条件

* 版本一致
* 避免冲突（比如gulp和grunt无法协作）

## 3. 工具体系的设计

我们首先来看一个项目的大概流程

* 初始化项目
* 运行和调试
* 测试
* 发布

那么就大概会包括如下工具

* Yeoman/xxx-cli/create-react-app
* less/sass/scss/postcss
* webpack/rollup/parcel
* mocha/chai
* travisCI

还不够，我们还需要一个包管理平台来保证团队成员的工具版本一致

轻量级的做法是，在项目初始化模板中定义npm script中定义

重量级的做法是，开发一个包装工具，在命令行中不直接使用命令，而使用包装过的命令（自定义一套脚手架+工具）

## 4. 监控

工具体系的结果虽然是软性的，但是也不能完全不做监控

纯粹的社区方案很难做监控，但是如果我们使用了之前的统一命令行入口包装，那么就可以做一些简单的统计工作了

一般来说，如下指标和开发者体验较为相关

* 调试/构建次数
* 构建平时市场
* 使用的工具版本
* 发布次数