## 1. 作用域

### 1.1 作用域是什么

#### 1.1.1 编译原理

js尽管被归类为动态或者解释执行语言，但事实上它是一门编译语言

在传统的编译语言中，程序中的一段源代码在执行前会经历三个步骤，统称为编译

> 1. 分词/词法分析

这个过程将由字符组成的字符串分解成有意义的代码块，这些代码块被称之为`词法单元`。比如`var a = 2;`可以被拆分为`var,a,=,2`

> 2. 解析/语法分析

这个过程是将词法单元转换成一个由元素逐级嵌套耦组组成的AST（抽象语法树）

> 3. 代码生成

将AST转换成可执行代码的过程。举例来说就是某种方法可以把`var a = 2`的AST转化成一组机器指令，用来创建一个叫做a的变量

以上的是传统的编译语言的过程，js引擎要复杂得多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化

#### 1.1.2 理解作用域

在理解作用域的过程中，有几个出现的演员

* 引擎: 从头到尾负责整个js程序的编译和执行
* 编译器: 负责语法分析和代码生成等脏活累活
* 作用域: `负责收集并且维护所有声明的标识符组成的一系列查询，并且实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限`

#### 1.1.3 编译器的查询类型

编译器的查询类型分为`LHS`和`RHS`。`console.log(a)`中用到的就是RHS，也就是只需要查询变量对应的值，而`a = 1`用到的就是`LHS`，我们来看一个例子

```
function foo(a) {
    var b = a
    return a + b
}
var c = foo(2)
```

RHS有4处，LHS有3处

> 为什么要学习LHS和RHS

因为在变量还没声明的时候，这两个查询的行为是不一样的

```
function foo(a) {
	console.log(b)
}
foo(2)
```

第一次对b进行RHS查询是无法找到该变量的，引擎会抛出ReferenceError异常。上面的代码执行就会报错

而如果改成如下这种LHS查询，如果一直找到了顶层中也无法找到的话，全局作用域中就会创建一个具有该名称的变量，并且将其返回给引擎，前提是程序中运行在非严格模式下(这种情况实际上就是没有var创建变量时自动为全局变量)

```
function foo(a) {
	b = a
}
foo(2)
```

#### 1.1.4 作用域嵌套

引擎从当前的执行作用域开始查找变量，如果找不到,就往上一层继续查找，当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止

#### 1.1.5 总结

作用域是一套规则，用于确定在何处和如何查找变量。如果是赋值操作，则是LHS，如果目的是获取变量的值，就会使用RHS。

### 1.2 词法作用域

作用域是一套用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找

作用域一共有两种主要的工作模型，第一种是最普遍的，也是大多数编程语言所采用的词法作用域。另外一种叫做动态作用域

#### 1.2.1 词法阶段

作用域气泡由其的作用域块代码写在哪里决定，它们是逐级包含的，比如

```
function foo(a) {
	function bar() {
		console.log(a)
	}
	bar()
}
```
这种情况是可以访问到a的

```
function bar() {
	console.log(a)
}
function foo(a) {
	bar()
}
```

这种情况bar中是无法访问到foo中的a的

#### 1.2.2 欺骗词法

如果说词法作用域完全由写代码期间函数所声明的位置来定义，怎么才可以在运行时来修改词法作用域呢？

js中有两种机制来实现，但是

:::danger
欺骗此法作用域会导致性能下降
:::

> eval

```
function foo(str, a) {
    eval(str)
    console.log(a, b) // 1, 3
}

var b = 2
foo("var b = 3", 1)
```

> with

```
var obj = {
    a: "1", b: "2", c: "3"
}
var obj2 = {a:"0", name: "obj2"}
function foo(o) {
    with(o) {
        a = 3;
        b = 4;
        c = 5;
    }
}
foo(obj)
foo(obj2)
// obj = {a:3,b:4,c:5}
// obj2 = {a:3,name:"obj2"}
```

要注意上面这个例子

* 没有这个属性时，with并不会像assign那样赋一个新属性上去
* 如果出现上面那种情况，属性实际上是加到了全局变量上

#### 1.2.3 词法作用域 vs 动态作用域

词法作用域最重要的特征就是它的定义特征发生在代码的书写阶段,而动态作用域是在运行时确定的

```
function foo () {
    console.log(a)
}

function bar () {
    a = 3
    foo()
}

var a = 2

bar()
```

在词法作用域（js）中会输出2，因为foo和bar都是单独包裹在全局作用域中的，但是在动态作用域中会输出3，因为它会顺着调用栈来查找a的值。js并不具备动态作用于（但是js中this的机制很像！）


#### 1.2.4 总结

作用域分为词法作用域和动态作用域，js是词法作用域，这意味着作用域由书写代码时函数声明的位置来决定的，动态作用域则是由调用栈来决定的。js中有eval和with两个机制来欺骗作用域，这两个机制都会使代码运行变慢，不要使用它们

### 1.3 函数作用域和块作用域

#### 1.3.1 函数作用域

* 隐藏内部实现=>`最小授权/最小暴露原则`
* 规避冲突=>全局命名空间+模块管理

#### 1.3.2 匿名函数和iife立即执行函数

匿名函数

* 在栈追踪中不会显示出有意义的函数名，使得调试很困难
* 调用自己的话，需要用到arguments.callee

### 1.3.3 块作用域

* with
* try/catch
* let
* const


```
{
    var a = 1
    let b = 2
}
console.log(a) // 1
console.log(b) // undefined
```

注意，for和if都是没有块作用域的，看下面例子

第一种情况，a,b,i均可以访问到

```
for (var i = 0; i < 5; i++) {
	var a = 1
	var b = 2
}

console.log(a,b,i) // 1,2,5
```

```
for (let i = 0; i < 5; i++) {
	var a = 1
	var b = 2
}

console.log(a,b,i) // 1,2,ReferenceError
```

```
for (let i = 0; i < 5; i++) {
	let a = 1
	var b = 2
}

console.log(a,b,i) // ReferenceError,2,ReferenceError
```

#### 1.3.4 总结

函数是js中最常见的作用域单元，它可以实现隐藏内部和规避冲突的功能。匿名函数也有不好的地方，那就是不好调试和不方便调用自己。在js中除了函数作用域还有几个块级作用域的实现形式

### 1.4 提升

#### 1.4.1 先有鸡还是先有蛋

```
a = 2
var a 
console.log(a)
```

```
console.log(a)
var a = 2
```

这两段代码的输出结果分别是什么？

#### 1.4.2 编译原理

引擎会在解释js之前首先对其进行编译，编译的第一部分的工作就是找到所有的声明，并且用合适的作用域将其关联起来

对于`var a = 2`，实际上是分为两个部分，`var a`是在编译阶段就进行的，`a = 2`是在运行到这一行代码时才运行

对于第一端代码，实际上是这样的

```
var a
a = 2
console.log(a) // 2
```

第二段代码

```
var a
console.log(a) // undefined
a=2
```

#### 1.4.3 函数优先

函数声明和变量声明（一定要正规的声明形式）都会提升，但是函数要比变量首先提升

```
foo() // 1

var foo = 2

function foo() {
    console.log(1)
}
 
// 这个不会被提升
foo = function() {
    console.log(2)
}

foo() // 2
```

#### 1.4.4 总结

对于简单的`var a = 2`这样一个语句，实际上js是将其分为两个阶段进行执行的，首先会在编译阶段将变量提升，其次会在语句阶段对变量进行赋值

函数提升（正规的方式）会比变量提升更早

如果没有var（let和const有暂时性死区）的变量则不会有提升比如`b=1`这样的全局变量声明，要理解也很简单，引擎完全可以把它当做一个简单的赋值语句而不是声明语句，只有var声明的才会提升

### 1.5 执行上下文

在一段js脚本执行之前，先有编译阶段，该阶段会先创建一个`全局执行上下文`环境（也是我们之前提到过的提升），现将代码中即将执行的变量和函数声明都拿出来，变量先暂时赋值为undefined，函数则是直接声明+定义，然后再开始正式执行代码。我们来看这样一段代码

```
console.log(a)  // undefined
var a = 100

fn('zhangsan')  // 'zhangsan' 20
function fn(name) {
    age = 20
    console.log(name, age)
    var age
}

console.log(b); // 这里报错
// Uncaught ReferenceError: b is not defined
b = 100;
```

a为undefined，但是b直接报错，就是因为b没有声明提升，LHS查询无法查询到。

此外，一个函数在执行之前，也会创建一个函数执行上下文，跟全局上下文差不多，区别在于函数上下文会多出this，arguments和函数的参数

## 2. 闭包

### 2.1 定义

> 当函数可以记住并访问到所在的词法作用域时，就产生了闭包

```
function foo() {
    var a = 2
    function bar() {
        console.log(a)
    }
    bar()
}
foo()
```

这种情况，还不算典型的闭包，它只是`词法作用域的查找规则`

```
function foo() {
    var a = 2
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo()
baz() // 2
```

上面这种情况，就是闭包。拜bar声明的位置所赐，它拥有涵盖foo（）内部作用域的闭包，使得该作用域一直存活，以供bar()在之后任何时间调用

> bar（）仍然持有对该作用域的闭包，这种引用，我们称之为闭包。
> 
> 无论通过何种手段，将内部函数传递收到所在的词法作用域之外，它都会持有对原始定义域的引用，无论在何处执行这个函数都会使用闭包

```
var fn
function foo() {
    var a = 2
    function bar() {
        console.log(a)
    }
    fn = bar
}
function baz() {
    fn() 
}
```

此时在bar中fn实际上就是bar函数的同一个引用，它现在处于原有函数foo的词法作用域之外，但是它还是持有对foo（）作用域的引用，这就是闭包

> 在本质上，无论何时何地，如果将函数当做第一级的值类型并且到处传递，你就会看到闭包在这些函数上的应用，只要使用了回调函数，实际上就是在使用闭包

因此，我们来看这个经典的bug

for函数是没有块作用域的，下面例子中会看起来它好像拥有,但那是因为for循环实际上是将循环中的代码unfold展开，本质上它就是一段长度为n的代码串

```
for(var i=0;i<10;i++){
    console.log(i) // 0,1,2,3...
}
```

那么，出现下面这种情况，即循环内部用到了循环变量，但是又没有马上执行，那么实际上，每个setTimeout里的i最终指向的都是全局作用域里的i，在真正引用的时候那就是10，所以会不断输出10

:::tip
延迟的回调会在循环结束才进行，哪怕它的时间间隔为0
:::

```
for(var i=0;i<10;i++){
    setTimeout(()=>console.log(i), 0) // 10,10,10...
}
```

解决办法也很简单，`iife`或者`let`

```
for(var i=0;i<10;i++){
    ((j)=>{
        setTimeout(()=>{
        console.log(j) // 0,1,2,3...
    })
    })(i)
}
```

```
for(let i=0;i<10;i++){
    setTimeout(()=>console.log(i), 0) // 0,1,2,3...
}
```

### 2.2 总结

#### 2.2.1 定义

当函数可以记住并且访问所在的词法作用域时，即使函数在当前词法作用域之外执行，这是就产生了闭包，我们将这种引用原先作用域的能力称之为闭包

#### 2.2.2 条件

* 必须要有外部的封闭函数，该函数必须至少被调用一次
* 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

#### 2.2.3 应用

* 访问函数定义时所在的词法作用域，防止其被回收
* 私有化变量
* 模拟块级作用域
* 创建模块

