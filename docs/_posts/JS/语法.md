## 1. 区分大小写

js中的一切都区分大小写（操作符，变量）

## 2. 注释

* 单行注释 // this is a comment
* /* 多行
* * 注释
* */

## 3. 严格模式

启用严格模式可以在代码顶部添加`"use strict"`.它是一个`pragma`（编译提示）,告诉引擎切换成严格模式，也可以指定函数在严格模式下运行

## 4. 自动分号

有时候js会自动为代码块不上缺失的分号，即自动分号插入ASI

> 如果js解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾和换行符之间除了空格和注释之外没有其他的内容时，它才会这么做

```
var a, b,
c // 这里的c就会被认为在上一行的声明里因为还存在着一个，
```

ASI是一个语法纠错机制

## 5. 语句

### 5.1 表达式和语句

```
var a = 3 * 6 
a
```

其中`3*6`就是一个表达式，`a`也是一个表达式，这两行代码都是包含表达式的`语句`。第一行可以被称为`声明语句`，3*6叫做`赋值表达式`，第二行`a`通常叫做表达式语句

### 5.2 语句的结果值

很多人都不知道语句都有一个结果值，比如语句`b = a`其结果值是赋给b的值，但是规范定义var的结果值是undefined,`var b = a`结果值就是undefined

代码块的结果值是最后一个语句/表达式结果，比如

```
var b
if(true) {
    b = 4 + 2
}
```

返回值为6

但是我们在代码里是没有办法获得这个结果值的，比如

```
var a,b
a = if(true) {
    b=4+2
}
```

因为语法不允许欧文们获得语句的结果值并将其赋值给另一个变量（至少目前不行），我们可以通过eval来获取（但是并不推荐）

```
var a,b
a = eval("if(true) {b=4+2}")
a // 42
```

### 5.3 if语句

```
if (condition) {
    ...
}
```

### 5.4 do-while语句

```
do {
    ...
} while(...)
```

适用于循环体内的代码至少要被执行一次的情景

### 5.5 while语句

```
while(condition) {
    ...
}
```

### 5.6 for语句

```
for (let i = 0; i < 10; i++) {
    ...
}
```

for语句中的三个表达式均是可以省略的

### 5.7 for-in语句

这是一种迭代语句，用于枚举对象的属性.js中对象的属性没有顺序，所以这样输出的顺序是不可预测的

```
for (let i in obj) {
    ...
}
```

### 5.8 label语句

使用label语句可以在代码中添加标签，以便将来使用。但是为了不增加代码的复杂度，我们要尽可能少使用标签语句

```
start: for(...){
    ...
}

...

continue start // 实现goto的功能
```

### 5.9 break和continue语句

```
for(...) {
    if(...) continue
}
```

```
outer
for(...) {
    if(...) break outer // break + 标签语句的结合
}
```

### 5.10 switch语句

```
switch(condition) {
    case value1: 
        ...
        break;
    case value2:
        ...
        break;
    default:
        ...
}
```

同时也可以通过不添加break来合并两种情况

```
switch(condition) {
    case value1: 
        // merge value1 & value2
    case value2:
        ...
        break;
    default:
        ...
}
```

### 5.11 with语句

with语句的作用是将代码的作用域设置到一个特定的对象中，with语句的语法如下

```
with(location) {
    var qs = search.substring(1)
    var hostName = hostName
    var url = href
}

// 等价于

var qs = location.search.substring(1)
var hostName = location.hostName
var url = location.href
```

### 5.12 try...catch语句

* finally的代码始终会执行，无论try里是否出现错误
* finally的return会覆盖try里的return，try里的会覆盖catch里的

finally中的代码段总是在try之后执行，如果有catch则在catch之后执行

```
function foo() {
    try {
        return 42
    }
    finally {
        console.log("hello")
    }
    console.log("never runs")
}
console.log(foo())
// Hello
// 42
```

try里将foo的返回值设置为42，然后执行finally。如果finally里抛出了异常，函数就会在此终止，如果已经设置了返回值，则抛弃该值。finally里返回的值会覆盖try里的

```
function foo() {
    try{
        return 42
    }
    finally {
        throw "oops"
    }
}
console.log(foo()) // Uncaught Exception: oops
```

如下例所示，try里的行为，像return,continue,break都不会立刻停止，而是要经过finally这个钩子

```
for(let i=0;i<10;i++){
    try {
        console.log(i)
        continue
    }
    finally {
        console.log(i)
    }
}
```

### 5.13 函数

在es6中，如果参数被省略或者值为undefined，则取该参数的默认值

对于es6中的某些参数默认值而言，参数被省略和被赋值为undefined效果都一样，但是某些情况还是存在区别的

```
function foo(a = 42, b = a + 1) {
    console.log(arguments.length, a, b, arguments[0], arguments[1])
}

foo() // 0 42 43 undefined undefined
foo(10) // 1 10 11 10 undefined
foo(10, undefined) // 2, 10, 11, 10, undefined
foo(10, null) // 2, 10, null, 10, null
```






