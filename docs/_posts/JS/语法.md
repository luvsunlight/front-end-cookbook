## 1. 区分大小写

js中的一切都区分大小写（操作符，变量）

## 2. 注释

* 单行注释 // this is a comment
* /* 多行
* * 注释
* */

## 3. 严格模式

启用严格模式可以在代码顶部添加`"use strict"`.它是一个`pragma`（编译提示）,告诉引擎切换成严格模式，也可以指定函数在严格模式下运行

## 4. 语句

### 4.1 表达式和语句

```
var a = 3 * 6 
a
```

其中`3*6`就是一个表达式，`a`也是一个表达式，这两行代码都是包含表达式的`语句`。第一行可以被称为`声明语句`，3*6叫做`赋值表达式`，第二行`a`通常叫做表达式语句

### 4.2 语句的结果值

很多人都不知道语句都有一个结果值，比如语句`b = a`其结果值是赋给b的值，但是规范定义var的结果值是undefined,`var b = a`结果值就是undefined

代码块的结果值是最后一个语句/表达式结果，比如

```
var b
if(true) {
    b = 4 + 2
}
```

返回值为6

但是我们在代码里是没有办法获得这个结果值的，比如

```
var a,b
a = if(true) {
    b=4+2
}
```

因为语法不允许欧文们获得语句的结果值并将其赋值给另一个变量（至少目前不行），我们可以通过eval来获取（但是并不推荐）

```
var a,b
a = eval("if(true) {b=4+2}")
a // 42
```

### 4.3 if语句



## 5. 歧义的语法规则

在js语法规则中，有时候同样的语法在不同的情况下会有不同的解释。这里举几个例子

### 5.1 大括号

> 对象常量

```
var a = {
    name: "a"
}
```
{...}被赋值给a，因而它是一个对象常量

>  标签

```
{
    name: "a"
}
```
这样只是一个普通的代码块。这里要注意括号里的内容，这个是js中一个不为人知的特性叫做标签语句，我们可以通过标签和continue/break来实现goto的功能

带标签的循环和代码块非常少见也不建议使用

### 5.2 代码块

```
[] + {} // "[object Object]"
{} + [] // 0
```

上者[]被当做一个值，而下者{}被当做一个独立的空代码块

## 6. 自动分号

有时候js会自动为代码块不上缺失的分号，即自动分号插入ASI

> 如果js解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾和换行符之间除了空格和注释之外没有其他的内容时，它才会这么做

```
var a, b,
c // 这里的c就会被认为在上一行的声明里因为还存在着一个，
```

ASI是一个语法纠错机制

## 7. 函数参数

在es6中，如果参数被省略或者值为undefined，则取该参数的默认值

对于es6中的某些参数默认值而言，参数被省略和被赋值为undefined效果都一样，但是某些情况还是存在区别的

```
function foo(a = 42, b = a + 1) {
    console.log(arguments.length, a, b, arguments[0], arguments[1])
}

foo() // 0 42 43 undefined undefined
foo(10) // 1 10 11 10 undefined
foo(10, undefined) // 2, 10, 11, 10, undefined
foo(10, null) // 2, 10, null, 10, null
```

## 8. try..finally

finally中的代码段总是在try之后执行，如果有catch则在catch之后执行

```
function foo() {
    try {
        return 42
    }
    finally {
        console.log("hello")
    }
    console.log("never runs")
}
console.log(foo())
// Hello
// 42
```

try里将foo的返回值设置为42，然后执行finally。如果finally里抛出了异常，函数就会在此终止，如果已经设置了返回值，则抛弃该值。finally里返回的值会覆盖try里的

```
function foo() {
    try{
        return 42
    }
    finally {
        throw "oops"
    }
}
console.log(foo()) // Uncaught Exception: oops
```

如下例所示，try里的行为，像return,continue,break都不会立刻停止，而是要经过finally这个钩子

```
for(let i=0;i<10;i++){
    try {
        console.log(i)
        continue
    }
    finally {
        console.log(i)
    }
}
```