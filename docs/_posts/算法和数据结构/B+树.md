![](https://static001.geekbang.org/resource/image/36/dc/36475968a64a81ceb13b8be7a1f20edc.jpg)

## 1. 定义

在使用数据库的同时，我们是否想过，数据库里的索引是如何实现的呢？底层实现使用的是什么数据结构和算法呢

我们假设我们要解决的问题，只包含两个常用的需求

* 根据某个值查找数据
* 根据区间值查找某些数据

我们主要从时间和空间两个方面来查找，也就是执行效率和存储空间

适合快速查找的数据结构有跳表，散列表，红黑树。最适合这种按区间查找的是跳表。事实上，数据库索引用到的数据结构和跳表非常接近，我们称之为B+树

我们可以对二叉查找树进行改造，树中的节点并不存储数据本身，而只是作为索引，除此之外，只是作为索引，除此之外，我们把每个叶子节点串在一条链表上，链表中的数据从大到小排列，经过改造的二叉树，就如图所示，看起来很像跳表

![](https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg)

![](https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg)

但是，如果我们要为1亿个数据构建二叉查找树，那索引中会包含大约1亿个节点，每个节点假设占用16个字节，那就需要大约1G的内存空间，那么如何解决这个索引占用太多内存的问题呢？

我们可以借助空间换时间的思路，将索引存储在硬盘中，不过这样的话，磁盘访问速度比内存慢很多，数据查询效率就会降低很多。我们优化的重点，是尽可能降低树的高度。我们可以将二叉树变成多叉树，这样的话树的高度就会显著降低

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读一页的数据，如果要读取的数据量超过一页的大小，就会触发多次IO操作，所以我们在选择m大小的时候，要尽量让每个节点的大小等于1一个页的大小。读取一个节点，只需要一次磁盘IO操作

但是b+树有一个问题，即在数据的写入过程中，会涉及索引的更新，而这可能会导致索引变慢。对于一个B+树来说，m是根据页的大小事先确定好了的，如果新加入节点，可能会让m的值超过page的大小，这个时候，我们可以分裂该节点，如果这次分裂导致父节点的m值也超过page的大小，则再次分裂

正是因为要保证B+树索引是一个m叉树，所以索引的存在会导致数据库写入的速度降低，实际上不光写入会降低，删除也会

## 2. 删除

今天，我们讲解了数据库索引实现，依赖的底层数据结构，B+树。它通过存储在磁盘的多叉树结构，做到了时间和空间的平衡，既保证了执行效率，也节省了内存

* 每个子节点中子节点的数量不能超过m，也不能小于m/2
* 根节点的子节点个数可以不超过m/2，这是一个例外
* m叉树之存储索引，并不真正存储数据，这点和跳表很像
* 通过链表将叶子节点串联在一起，这样可以方便查找
* 一般情况下，根节点会被存储到内存中，其他节点存储在磁盘中