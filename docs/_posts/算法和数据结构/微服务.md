![](https://static001.geekbang.org/resource/image/08/c3/089d61210d5ce4843c9fe3af59dab0c3.jpg)

## 1. 定义

微服务是最近几年才兴起的概念，简单点说就是将复杂的大的应用，解耦拆分成几个小的应用，这样的话，有利于团队组织架构的拆分。而且每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不过有利就有弊，大应用拆分成微服务之后，服务之间的调用关系变得更加复杂，平台的整体复杂熵增加，出错的概率提高了很多量级。专业那个，服务治理便成了微服务的一个技术重点

服务治理，简单点说就是管理微服务，保证平台整体正常，平稳地运行。服务治理设计的内容比较多，比如鉴权，限流，降级，熔断，监控告警等。这些服务治理功能的实现，底层依赖大量的数据结构和算法

### 1.1 鉴权

假设我们有一个微服务叫用户服务，包含了诸如用户注册，登录等。但是并不是公司内部所有应用，都可以访问这个用户服务，也不是每个有权限访问的应用，都可以访问到用户服务的所有接口

![](https://static001.geekbang.org/resource/image/1a/3d/1a574c209ab80e2dcdc9a52479d4f73d.jpg)

要实现接口鉴权功能，我们需要事先将应用和接口的访问权限规则设置好。当应用访问一个接口时，我们就可以拿应用的请求url，在规则中进行匹配，如果匹配成功，就说明允许访问，如果未成功，就说明没有权限

#### 1.1.1 精确匹配

我们可以用散列表来存储服务和请求链接的关系，匹配的时候可以用KMP，BM，RF等。规则不会经常变动，所以为了加快查找速度，我们可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构。之后我们再匹配的时候，我们可以通过二分查找来实现

#### 1.1.2 前缀匹配

我们可以用Tries树，不过在这里，Tries树种的每个节点不是存储单个字符，而是存储接口被“/”分割的子目录，因为规则不经常变动，所以在Tries树种，我们把每个节点的子节点们，组织成有序数组这种数据结构，当在匹配的时候，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点

![](https://static001.geekbang.org/resource/image/69/b9/691d7f056fe48b8598f6f86568212db9.jpg)

#### 1.1.3 模糊匹配规则

如果我们的规则更加复杂，规则中包含通配符，比如**表示匹配多个规则

![](https://static001.geekbang.org/resource/image/f7/32/f756e2fef50776442be41e48d7aa5532.jpg)

我们可以结合实际情况，比如把不包含通配符的规则，按照Tries树来做，生下来的是少数包含通配符的规则，我们只需要将其简单存储在一个数组中即可，尽管匹配起来较慢，但是毕竟规则少，所以这种方法也是可以接受的

### 1.2 限流

限流，即对接口调用的频率进行限制，比如每秒钟不能超过100次调用，超过之后，我们就拒绝服务

根据不同的限流粒度，限流又可以分为很多类型，比如给每个接口限制不同的访问频率，或者是给所有接口总的访问频率，又或者更精细粒度

#### 1.2.1 精确限流

最简单的办法就是固定时间窗口限流，这样方法简单，但是策略过于粗糙，无法应对两个时间窗口临界时间内的突发流量

假如我们的限流规则是，每秒钟不能超过100次请求接口，第一个1s时间窗口内，100次接口的请求都集中在最后10s内，在第二个1s的时间窗口内，100次接口请求都是集中在最开始的10ms内。虽然两个窗口内流量都符合限流要求，但是在临界的20ms内，会集中出现200次接口请求

进一步的改造就是任意时间窗口内，接口的请求数都不能超过某个阈值。称之为滑动时间窗口限流法

流量经过滑动时间窗口限流算法之后，可以保证任意一个1s内的时间窗口内，都不会超过最大允许的限流值，那么我们可以用循环队列来做

## 2. 总结

关于鉴权，我们讲了三种不同的规则匹配模式，精确匹配，前缀匹配和模糊匹配。对于不同的规则，使用不同的数据结构。对于精确匹配，我们利用有序数组来存储每个应用的规则集合，并且利用二分查找和字符串匹配，来匹配请求url和规则。对于前缀匹配，我们用tries树来存储规则集合。对于模糊匹配，我们将模糊匹配规则和普通规则分开，可以大幅增加判断效率。关于限流，一个是固定时间窗口的方法，缺点是无法完全避免峰值，解决方法是用循环队列来实现任意时间窗口的限流