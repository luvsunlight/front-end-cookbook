![](https://static001.geekbang.org/resource/image/05/b3/059c152aaa2cf0203a48bc6137052fb3.jpg)

## 1. 定义

在游戏中，人物的自动寻路功能是怎么实现的呢？

我们要实现的策略是，从一个点到另一个点，走的路不能太绕，又要躲过障碍物

看上去最短路径好像符合我们的要求，但是我们说过，最短路径的执行耗时很多。实际上，像出行路线规划，游戏寻路，这些真实软件开发中的问题，`一般情况下，我们都只需要寻求一个最优解就可以了`，那么如何快速找出一条接近于最短路线的次优路线呢？

如何将Dijkstra算法改造成我们今天学习的A*算法呢？

Dijkstra算法实际上有点类似于BFS算法，它每次找到跟起点最近的顶点，往外扩展，这种往外扩展的思路，其实有些盲目

![](https://static001.geekbang.org/resource/image/11/dd/11840cc13071fe2da67675338e46cadd.jpg)

像这个例子，首先计算的是123三个点，这个方向和我们期望的方向是反着的。之所以会跑偏，就是因为我们是按着顶点和起点的路径长度的大小来安排出队列顺序的。但是我们并没有考虑这个顶点和终点的距离，所以尽管123离起始点最接近，但是离终点却越来越远。

当我们遍历到某个顶点时，从起点到这个点的距离是确定的，但是这个点到终点的距离是未知的。我们可以用其他估计值来代替

这里我们可以通过这个顶点和终点之间的直线距离，也就是欧几里得距离，来近似估计这个顶点和重点的路径长度。专业的叫法是`启发函数`。因为欧几里得距离的计算会涉及到比较耗时的开方根计算，我们一般通过一个更加简单的距离计算公式，那就是`曼哈顿距离`，曼哈顿距离是两点之间横纵坐标的距离之和，计算过程只涉及加减和符号反转，比欧几里得距离更加高效

在Dijkstra算法里，我们只是通过单纯的顶点和起点之间的路径长度，来判断谁先出队列，现在有了顶点到终点的路径长度，这里我们通过路径长度以及该点到终点的曼哈顿距离来共同估计哪个顶点先出队列，这里的专业叫法是`估价函数`

A*算法有利用到贪心算法的思想，所以它没有考察到所有可能的路径

要用A*算法来解决地图寻路问题，我们只需要将地图抽象成图就可以了。不过游戏中的地图可能并不存在规划非常清晰的道路，没有办法抽象出来，这个时候，我们可以将地图栅格化，再将地图抽象成边权值只有1的有向图。我们再套用A*算法

## 2. 总结

我们今天讲的A*算法，属于一种启发式搜索算法。实际上启发式的搜索算法还有很多。启发式搜索算法利用估价函数，在Dijkstra算法的基础上进行改进，尽可能朝着最有可能到达终点的方向前进。A*算法得到的路径，并不一定是最优路径，但是在实际的应用中，我们并不需要最优的算法。因此启发式搜索算法可以很好得平衡路线质量和执行效率






