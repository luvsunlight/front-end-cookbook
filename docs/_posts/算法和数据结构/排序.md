![](https://static001.geekbang.org/resource/image/7c/67/7c40ffed3d9263a00af4d83198b54a67.jpg)

## 1. 定义

![](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

## 2.如何分析一个排序算法

### 2.1 排序算法的执行效率

* 最好情况，最坏情况，平均情况时间复杂度
* 时间复杂度的系数，常数，低阶
* 比较次数和交换次数

### 2.2 排序算法的内存消耗

针对排序算法的空间复杂度，我们还引入了一个新的概念，即原地排序。特指空间复杂度为O(1)的排序算法

### 2.3 排序算法的稳定性

仅仅用执行效率和内存小号来衡量排序算法的好坏是不够的，我们还有一个重要的衡量指标，那就是稳定性，这个概念是说，如果待排序的序列中存在值相等的元素，经过排序后，相等元素的先后顺序不变

在实际应用中，比方说，我们可以先对数据进行按时间排序，然后再对数据进行业务排序，这样最终得到的数据，是在业务排序的基础上进行了时间排序

![](https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

## 3. 冒泡排序

冒泡排序只会操作相邻的两个数据，每次冒泡操作都会让相邻的两个元素进行比较，看是否满足大小关系要求。一次冒泡会让至少一个元素移动至它应该在的地方

![](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

实际上，这样的冒泡排序还可以进行优化，当某次冒泡操作已经没有数据交换时，说明已经完全有序，不用再进行后续的操作

* 冒泡排序是原地排序（空间复杂度为O(1)）
* 是稳定的排序算法
* 时间复杂度是O( n^2 )

如果直接按照概率论来计算冒泡排序的时间复杂度，还是很复杂的。我们这里引入[有序度](https://baike.baidu.com/item/%E6%9C%89%E5%BA%8F%E5%BA%A6)的概念

### 3.1 有序度

有序度即为数组中具有有序关系的元素对的个数，逆序度则相反

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

比如一个正序数组a[n]，其有序度为n，如果为倒序数组，则有序度为0，逆序度为n

![](https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg)

那么，对于冒泡排序来说，进行的交换次数 = `n*(n-1)/2-初始有序度`

最好的情况下，交换次数=`0`，最坏的情况下，交换次数=`n*(n-1)/2`

交换的平均时间复杂度=`n*(n-1)/4`，而比较操作比交换操作多，但是上限是O(n^2)，故冒泡排序的平均时间复杂度=o(n^2)

## 4. 插入排序

首先我们来回顾，在有序列表中，我们是怎么插入数据的

想清楚后，我们再来看插入排序

![](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

我们首先将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个就是数组的第一个元素，插入算法的核心就是从未插入区间中取出元素，并且在有序区间中找到对应的位置并且插入，重复这个过程，直至未排序区元素为空

插入排序在进行插入时不是进行更换位置（这一点和选择排序不一样）

注意一个细节，如果是用数组实现的话，那么遍历元素时是从后往前遍历，这么做的好处是一边遍历进行比较，一边可以挪动数据。如果是链表则没有这个必要了

* 是原地排序算法
* 是稳定的排序算法、
* 平均时间复杂度O(n^2)

## 5. 选择排序

选择排序的思路有点类似于插入排序，也分已排序区间和未排序区间，但是每次排序都会从未排序区间找到最小的元素，将其与未排序区间的首位进行互换，还有初始已排序区间为空

![](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

* 是原地排序算法
* 是不稳定的排序算法（这也是选择排序不如前两者的原因）
* 平均时间复杂度O(n^2)

## 6. 归并排序

![](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

归并排序思想很简单，首先对数组进行对半分，两个部分依次排序，然后再合并两个数组即可

![](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

### 6.1 思路

需要一个主函数main，一个辅助函数merge

主函数main的功能是将一个数组输出成一个有序数组，实现逻辑是将原本数组均匀分裂成两个数组，然后依次调用主函数变成有序数组，最后通过merge函数合并

merge函数的逻辑是给定两个有序数组，将其合并成一个有序函数

关键点在于merge函数，它接受三个参数，完全数组和分裂的两个数组；merge首先是将两个分裂数组合并成一个有序数组，然后将这个数组的值赋给原数组

### 6.2 特点

* 是稳定的排序算法
* 时间复杂度为O(nlog n)，并且在任何情况下都是如此，这一点比快排好
* 不是原地排序，空间复杂度为O(n)（因为合并这个操作没有办法原地进行）

### 6.3 时间复杂度

计算递归问题的时间复杂度，T(a)T(b)为两个子任务的耗时，K为合并操作的耗时

```
T(a) = T(b) + T(c) + K
```

然后用数学归纳法可以得到结果

## 7. 快排

### 7.1 原理 

![](https://static001.geekbang.org/resource/image/66/dc/6643bc3cef766f5b3e4526c332c60adc.jpg)

原理类似于归并排序，首先在当前数组随机找到一个pivot,然后将数组小于pivot的元素放在其左边，大于其的元素放在右边（这个过程放在partition里），然后不断递归

### 7.2 特点

* 不是稳定的（因为在partition过程中，各个元素不是逐个比较而是和指标元素pivot比较，所以重复元素的位置可能会发生变化）
* 是原地排序（我们运用了一个巧妙的办法，即partition函数的细节）

### 7.3 快排 vs 归并排序

![](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

我们可以看到归并排序是从下而上的，先处理子问题，然后再合并，而快排则完全相反，先分区，再处理子问题

## 8. 线性排序

时间复杂度为O(n)的排序算法，但是其应用条件各有各的限制

### 8.1 桶排序

#### 8.1.1 原理

![](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

原理很简单，假设数据大小为n，我们将数据区域划分成m个桶，遍历数据并将数据放在对应的桶里，然后每个桶内做出排序，最后将所有桶中的数据依次取出，即得到排序号的数组

#### 8.1.2 时间复杂度

我们假设数据是均匀投放到桶中，每个桶的容量为`n/m`，每个桶内做快排，则一个桶的时间复杂度为`n/m * log(n/m)`，n个桶的时间复杂度为`m*n/m*log(n/m) = n * log(n/m)`，当m接近于n时，我们可以认为时间复杂度为O(n)

#### 8.1.3 特点

* 时间复杂度为O(n)
* 待排序数据要很容易划分成桶，并且桶与桶之间要有天然的大小顺序
* 数据在各个桶之间的分布是均匀的，极端情况下，时间复杂度可能退化成O(nlogn)
* 适用于外部排序（数据存储在外部磁盘中，数据量大，内存有限，无法将数据全部加载到内存中）（做法是，先扫描文件确定范围，然后根据内存和数据分布情况，划分桶的个数，在内存中完成每个桶的排序，最后依次取出，`如果遇到分布不均匀的情况，比如某一个桶的数据量特别大，内容又一次读不下，我们可以再对这个桶进行桶排序`）
* 不是稳定的排序算法（因为内部用到了快排）（如果桶数=数组长度，则是）

### 8.2 计数排序

#### 8.2.1 原理

计数排序实际上是桶排序的一种特殊情况，当`数据范围并不大时`，我们可以划分n个桶，其中n是数据的范围（max-min）

#### 8.2.2 特点

* 只适用于数据范围不大的场景中
* 只能给非负整数排序，如果要排序的数据是其他类型的话，要将其在不改变相对大小的情况下，转化为非负整数（比如说都是一位小数，我们还需要乘以10再进行计数排序）

### 8.3 基数排序

#### 8.3.1 原理

先来看这样一个问题，如果要对10w个手机号进行排序，应该怎么处理？注意到我们可以发现一个规律，如果手机号的前几位就已经大，后面的几位都不用看了，于是我们可以逐位进行比较

#### 8.3.2 特点

* 要求数据像电话号码一样可以分割出独立的位来，而且位之间有递进的关系
* 每一位的数据不能太大，要可以用线性排序算法来排序
* 如果要排序的数据不是等长，则可以用0把不足的位补齐

Question

* 为什么用电话号码的不可以用桶排序来做
* 计数排序和基数排序的实现
* 基数排序可以从左边开始吧，也是稳定的

## 9. 总结

![](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)

在实际开发中，冒泡排序和选择排序都用的少，插入排序可能用的更多

冒泡排序和插入排序虽然在表现上很类似，但是日常我们更倾向于插入排序。从赋值角度上来说，插入排序只有一个赋值操作，而冒泡有三个

![](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

## 10. 如何实现一个高效的排序函数

线性排序算法时间复杂度低，但是适用场景较为特殊，不通用

一般来说时间复杂度为O(nlogn)的算法更为通用。但是归并排序因为不是原地排序，除了原有数据之外还需要占用额外的内存，就一般通用度不高。总的来说，快速排序最适合来作为自己实现的排序函数

### 10.1 如何优化快速排序

当数据本身接近有序或者就是有序的情况下，快速排序的时间复杂度就会退化成O(n^2)，实际上出现这种原因就是因为我们区分点选择的不好。

最理想的区分点是**备份区点分开的两个分区中，数据的数量差不多**

#### 10.1.1 三数取中法

我们从区间的首尾中间分别取一个数来，对比大小。当然如果要排序的数组比较大，三数取中可能要换成五数乃至更多

#### 10.1.2 随机法

从区间中随机找一个值，这种方法不能保证每次都很好，但是也不会每次都很差，平均情况下这样是比较好的

同时，快速排序是基于递归的，那么递归就会有解释器或者编译器的递归深度的问题，有两个解决办法，一个是限制递归深度，当递归深度超过我们自己设定的阈值就停止递归，第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈出栈的问题

### 10.2 举例分析

以Glibc中的qsort来看

* 优先使用归并排序来输入数据（如果数据量小的话，归并排序所造成的额外开销并不大）
* 数据量大时，会改为快速排序
* 使用三数取中法来获取pivot
* 在快排的过程中，一旦元素的个数小于4，它就会采用插入排序。因为对于小规模的数据来说，O(n^2)不一定比O(nlogn)差

V8 引擎 sort 函数只给出了两种排序分别是： InsertionSort 和 QuickSort，数组长度小于等于 10 的用插入排序 InsertionSort，比10大的数组则使用快速排序 QuickSort
地址：https://github.com/v8/v8/blob/master/src/js/array.js
Mozilla/Firefox : 归并排序（jsarray.c 源码）
Webkit ：底层实现用了 C++ 库中的 qsort() 方法（JSArray.cpp 源码）