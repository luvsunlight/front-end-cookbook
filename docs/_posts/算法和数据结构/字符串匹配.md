![](https://static001.geekbang.org/resource/image/b9/66/b997edcd68d6f7393275659f8653a766.jpg)

## 1. 定义

### 1.1 BF算法

BF(Bruce Force)中文叫做暴力匹配算法，也叫朴素匹配算法

> 我们在主串中，分别检查位置分别是0,1,2...n-m的n-m+1个子串，看有没有跟模式串匹配的

![](https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg)

> 特点

* 时间复杂度O(n*m)
* 是一个比较常用的字符串匹配算法（因为实际开发中，字符串的规模不会太大，而且统计意义上，大部分情况下，算法执行效率比这个高很多。思想简单，代码实现也简单，在工程中，在满足性能要求的前提下，简单是首选，这也就是我们常说的KISS（Keep it Simple and Stupid）设计原则）

### 1.2 RK算法

在BF算法中，我们是对n-m+1个子串分别和要比较的子串进行对比，RK算法则是我们首先对n-m+1个子串求哈希值，然后逐个和模式串的哈希值比较大小。如果某个子串的哈希值和模式串相等，那就说明对应的子串和模式串匹配，因为哈希值是一个数字，所以这样效率就比较高了

但是这么做的话，虽然比较的效率高了，但是计算哈希值时还是需要遍历每个字符，算法整体的效率并没有得到改变。有没有什么办法来提高计算哈希值的效率呢

我们假设要匹配的字符串的字符集中只包含k个字符，我们可以用一个k进制的数来表示一个子串，这个k进制的数转化为十进制的数，作为哈希值

重点来了，这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定的关系

![](https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg)

也就是说，我们可以通过s[i-1]的哈希值很快计算出s[i]的哈希值

![](https://static001.geekbang.org/resource/image/f2/ee/f298f1e5c93b205345b9cd6d9c53fbee.jpg)

不过这里有一个小细节需要注意，那就是26^(m-1)这部分的计算。我们可以通过查表的方式来提高效率

![](https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg)

当然模式串很长，相应的主串中的子串也会很长，哈希值就会很大，如果超过了计算机中的整数范围应该怎么办？

其实很简单，之前我们的哈希函数是没有散列冲突的。现在我们可以设计一个有散列冲突的函数，比如从原来的所有位数算一个n进制数变成所有位数相加

这样得到的哈希值范围会小很多，虽然哈希冲突的概率也会小很多。哈希冲突时的解决办法也很简单，如果相等，再比较一下子串本身即可

当然我们还是需要控制一下哈希算法，让其冲突概率不那么高，不然会导致哈希算法的效率退化

### 1.3 BM算法

对于工业级的软件开发来说，我们希望算法尽可能高效，并且在极端情况下，性能也不要退化得太严重了。有没有比BF算法和RK算法更加高效的字符串匹配算法呢？

#### 1.3.1  原理分析

BM算法包含两个部分，分别是坏字符规则和好后缀规则。

> 坏字符规则：以前的算法中，我们是在主串从前往后和模式串进行匹配。而BM算法里，我们是从后往前

![](https://static001.geekbang.org/resource/image/29/e1/29521f541dd45e13162013b3364fece1.jpg)

![](https://static001.geekbang.org/resource/image/54/9e/540809418354024206d9989cb6cdd89e.jpg)

我们从模式串的末尾往前进行匹配，当我们发现某个字符没法匹配时，我们称之为坏字符

![](https://static001.geekbang.org/resource/image/22/da/220daef736418df84367215647bca5da.jpg)

c就是坏字符，它和abd都没法匹配。出现了坏字符，我们可以直接往后移动3位

![](https://static001.geekbang.org/resource/image/4e/64/4e36c4d48d1b6c3b499fb021f03c7f64.jpg)

然后这个时候，我们发现，虽然a没有和d匹配，但是它能和a匹配，于是我们再将模式串后移2位

![](https://static001.geekbang.org/resource/image/a8/ca/a8d229aa217a67051fbb31b8aeb2edca.jpg)

利用坏字符规则，BM算法在最好的情况下时间复杂度非常低，是O(n/m)，即每次都直接后移m位

不过单纯使用坏字符规则是不够的，因为这样有可能出现倒退的情况，因此BM算法还需要`好后缀规则`

> 好后缀规则

![](https://static001.geekbang.org/resource/image/d7/8a/d78990dbcb794d1aa2cf4a3c646ae58a.jpg)

当出现了这样的情况，我们该如何移动模式串呢？我们把已经匹配好的bc称为好后缀，即为{u},我们拿它在模式串中查找，如果找到了另外一个跟{u}相匹配的子串，那么我们就将模式串滑动到子串和主串对齐的地方

![](https://static001.geekbang.org/resource/image/b9/63/b9785be3e91e34bbc23961f67c234b63.jpg)

如果在模式串中找不到另外一个等于{u}的子串，我们就直接将模式串，滑动到朱传忠{u}的后面，因为之前的任何一次向后滑动都没有匹配到

![](https://static001.geekbang.org/resource/image/de/cd/de97c461b9b9dbc42d35768db59908cd.jpg)

不过直接移动到{u}的后面，这样做是否太过头了呢？我们可以看下面一个例子，就会错过完全匹配的情况

![](https://static001.geekbang.org/resource/image/9b/70/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg)

所以针对这种情况，我们不仅要看好后缀在模式串中，是否有另外一个匹配的子串，我们还要考察后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。

后缀子串就是最后一个字符跟s对齐的子串，前缀子串就是起始字符跟s对齐的子串来我们从好后缀的后缀子串中，找到一个最长的并且能跟模式串的前缀串相匹配的，记为{v},然后将模式串滑动到如图所示的位置

![](https://static001.geekbang.org/resource/image/6c/f9/6caa0f61387fd2b3109fe03d803192f9.jpg)

那么怎么判断该使用好后缀和坏字符规则呢？

在每次匹配的过程中，一旦发现坏字符，先执行坏字符规则，如果发现存在好后缀，还要执行好后缀规则，并从两者中选择后移距离最大的方案执行

### 1.4 KMP算法

BM算法是业界最高效，最常用的字符串匹配算法。不过字符串匹配算法，最知名的还是KMP算法

#### 1.4.1 算法的思想

核心思想和BM非常相近，在模式串和主串匹配的过程中，当遇到不可匹配的字符时，我们希望能找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况

## 2. 总结

BF算法也叫暴力/朴素算法，它的最坏时间复杂度为O(n * m)，不过因为简单不易出bug，它的应用范围也很广，RK算法是在BF算法的基础上增加了哈希算法，让比较的过程快速了很多，它的时间复杂度为O(n),和BF算法比起来，它的效率提高了很多，不过也要看哈希函数的设计，如果子串的规模太大，不能用数字表示，我们可以更换一个简单一点的哈希函数（散列冲突更频繁），如果遇到冲突了再比较子串本身，这样做理想情况下时间复杂度还是保持在O(n)

对于BM算法，它有两种规则，坏字符规则和好后缀规则。虽然它比较复杂，但是在实际的软件开发中，特别是一些文本编辑器中应用得比较多，如果一遍看不懂的话就多看几遍

BM算法的核心思想是，利用模式串本身的特点，在模式串某个字符和主串不能匹配的时候，将模式串多往后移几位，一次来减少不必要的字符比较，提高匹配的效率。好后缀规则可以独立于坏字符规则来使用，因为坏字符规则的实现比较耗内存
