![](https://static001.geekbang.org/resource/image/fd/b2/fdd7e83c7816075a638f02f97558fbb2.jpg)

## 1. 定义

* 堆必须是一个完全二叉树，即除了最后一层，每一层节点个数都是满的，最后一层的节点都靠左排列
* 堆中每个节点的值都**必须**大于等于（大顶堆）或者小于等于（小顶堆）其子树中每个节点的值

## 2. 实现

我们之前说过，完全二叉树比较适合用数组来存储，用数组来存储二叉树是非常节省存储空间的

### 2.1 插入

堆插入的过程称之为**堆化**，堆化分为从下往上和从上往下的

#### 2.1.1 从下往上的

堆化很简单，就会顺着节点所在的路径，向上或者向下，对比然后交换

![](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)

让新插入的节点和父节点对比大小，如果不满足父子节点的大小关系，我们就互换节点，一直重复直至满足

### 2.2 删除

![](https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg)

当然如果这么做有一个问题，那就是最后形成的堆不一定是一个完全二叉树

实际上，我们可以稍稍改变一下思路，我们把最后一个节点放在堆顶，然后利用同样的父子节点对比方法，这就是**从上而下的堆化方法**（即每个节点和自己的子节点比较）

![](https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg)

## 3. 堆排序

堆排序的时间复杂度非常稳定，是O(nlogn)，而且它还是原地排序算法，如此优秀，是怎么做到的呢

### 3.1 建堆

我们首先把数组原地（即空间复杂度为O(1)）建一个堆，这个时候有两种思路

第一个思路是首先建立只有一个元素的堆，然后再将元素依次插入

第二个思路和第一种截然相反。第一种思路是从前往后处理数据，并且每个数据插入堆时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化

![](https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg)

单纯看图可能还不太好理解，实际上就是每一步我们都对下标从n/2到1的数据进行**从上而下的堆化**，下标是n/2+1~n的节点是叶子节点，我们不需要堆化

#### 3.1.1 时间复杂度

对每个节点堆化的过程中，需要交换和比较的节点数量，跟这个节点的高度k成正比。我们只需要叠加每一层的节点个数和对应层数的乘积就可以得到时间复杂度

最终的时间复杂度为O(n)

![](https://static001.geekbang.org/resource/image/89/d5/899b9f1b40302c9bd5a7f77f042542d5.jpg)

### 3.2 排序

建堆结束后，数据中的数据已经是按照大顶堆的特性来组织的了。数组中的第一个元素也就是堆最大的元素，我们将其和最后一个叶子节点互换，并且进行堆化，然后再一直重复这个步骤

![](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)

### 3.3 时间复杂度

建堆的时间复杂度为O(n),排序的时间复杂度为O(nlogn)，所以整体的时间复杂度为O(nlogn)

排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序

## 4. 快排vs堆排序

在实际应用中，快排往往比堆排序表现得性能更好，这是为什么

* 堆排序数据访问的方式没有快速排序友好。堆排序的数据是跳着访问的，这样对CPU的缓存不友好
* 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快排

## 5. 应用

### 5.1 优先级队列

优先级队列，顾名思义，它应该首先是一个队列，队列最大的特性是先进先出，不过在优先级队列中，是优先级最高的最先出队

实现优先级队列的方法有很多，但是堆是最直接最高效的，因为堆和优先级队列的概念最接近

#### 5.1.1 合并有序小文件

假设我们有100个小文件，每个文件的大小是100mb，每个文件内存储的都是有序的字符串，我们希望将这100个小文件合并成一个有序的大文件，我们就会用到优先级队列

显然，合并两个文件时，我们可以用双指针法，但是当数量变多了，我们是不能再使用这个方法的

我们可以使用小顶堆，首先取100个文件的最小元素建小顶堆，最顶端元素即为最小元素，我们取这个元素出堆，并且从小文件中取出下一个字符串，重复这个过程，直至所有文件均放入

#### 5.1.2 高性能定时器

假设我们有一个定时器，维护了很多定时任务，如果我们每隔1s就选择检查一遍所有任务的时间，这样无疑很费时。

我们可以用优先级队列来完成，我们按照任务设定的时间，将任务存储在优先级队列中，队列首部存储的是最先执行的任务

### 5.2 top K

求topK的问题可以抽象成两种，一种是针对静态数据集合，也就是说数据集合事先确定，不会再变，另一类是针对动态数据集合

针对静态数据，我们可以维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出数据和堆顶元素比较，如果比堆顶元素大，则删除堆顶元素，然后将该元素插入到堆中，如果小则不处理，遍历完整个数组后，堆中的数据就是topK了，时间复杂度为O(nlogK)

针对动态数据，如果每次查询都是重新计算，那么时间复杂度就是nlogK，我们可以一直维护一个大小为K的小顶堆，每次插入元素都和堆顶元素做出比较，这样，无论什么时候需要查询当前topK

### 5.3 中位数

![](https://static001.geekbang.org/resource/image/18/b6/1809157fdd804dd40a6a795ec30acbb6.jpg)

对于静态数据，中位数是固定的，尽管排序的代价很大，但是边际成本会很小。但是如果我们面对的是动态的数据，中位数会不停地变动，这样效率就不高了

![](https://static001.geekbang.org/resource/image/08/99/08c29d3e014a4baf5f8148c2271e6099.jpg)

## 6. 总结

* 堆是一种完全二叉树
* 最大的特性是每个节点的值都必须大于等于或者小于等于子节点的值
* 两个操作分别是插入和删除，这两个操作都要用到堆化，插入的时候，我们使用从下往上，删除的时候，我们使用从上往下，两个操作的时间复杂度都是O(logn)
* 堆排序的过程分为建堆和排序，建堆需要对n/2~1下标的数据进行堆化，时间复杂度为O(n)，排序需要迭代地将堆顶的元素放在末尾，堆大小-1并且堆化，时间复杂度为O（nlogn）


