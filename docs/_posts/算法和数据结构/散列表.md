![](https://static001.geekbang.org/resource/image/b1/02/b1b5da27544870c9376004006387db02.jpg)

## 1. 定义

散列表实际上是一种数组的拓展，它用的是数组支持下标随机访问的特性

:::tip
散列表，内部维护了一个数组，它接受一个键key，通过内部的散列函数将key转化成对应的数组下标，然后再通过下标访问数组的的值，key => index => value。理想情况下，不同的key对应的下标都不一样，但是这种情况不可能，我们就有一系列解决冲突的办法
:::

一个好的散列函数的基本要求

* 散列函数计算得到的散列值为非负整数
* key1 = key2, hash(key1) = hash(key2)
* key !== key2, hash(key1) !== hash(key2)

但是实际上第三点是几乎无法满足的，即使是业界著名的md5，crc，sha等哈希算法，也无法完全避免这种散列冲突，而且因为数组的存储空间有限，也会加大散列冲突的概率

所以散列表的查询效率并不能笼统地说成O(1)，它跟散列函数，装载因子，散列冲突都有关系，如果散列函数设计得不好或者装载因子过高，都有可能导致查询效率下降

## 2. 解决散列冲突

### 2.1 开放寻址法

核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。如何探测空闲位置呢？

#### 2.1.1 线性探测

当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直至找到为止

散列表跟数组一样，不仅支持插入，查找操作，还支持删除操作，对于使用线性探测发解决冲突的散列表，删除操作不能知识将要删除的元素设为空，因为这样会导致原有的查找算法失效。更好的做法是将被删除的元素标记为deleted，当线性探测查找时直接跳过有deleted标记的数据

![](https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg)

线性探测的问题很大，当散列表中插入的数据越来越多时，散列表发生冲突的可能性越来越大，空闲位置越来越少，复杂性也就越高

一般情况下，我们都要尽可能保证散列表中有一定比例的空闲槽位，我们用`装载因子`来表示空位的多少

`散列表的装载因子 = 填入表中的元素个数 / 散列表的长度`

### 2.2 链表法

链表法是一种更加常见的散列冲突解决办法

![](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

在散列表中，每个桶/槽对应一个链表，所有散列值相同的元素我们都放在对应的链表中

当插入时，我们只需要通过散列函数来计算出对应的散列槽位，将其插入到对应的链表，查找删除同理

## 3. 如何设计一个工业级别的散列表

在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里，如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就会从O（1）急剧退化为O(n)

数据为n，查询效率就会退化n倍。这样就有可能查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的，这也就是散列表碰撞攻击的基本原理

### 3.1 设计原则

* 设计不能太复杂，太复杂的散列表势必会消耗很多计算时间，也就间接影响到散列表的性能
* 散列函数生成的值要尽可能随机并且分布均匀，这样才能避免或者最小化散列冲突

实际工作中，我们还需要综合考虑各种因素，比如关键字的长度，特点，分布，还有散列表的大小等

eg.

以手机号存储为例，因为手机号前几位重复的可能性很大，但是后几位比较特殊，所以我们可以取手机号的后四位作为散列值（数组下标），这样我们就是结合了实际情况，称之为”数据分析法

### 3.2 装载因子太大了怎么办

装载因子太大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率越大

对于没有频繁操作的静态数据集合的话，我们很容易根据数据特点来设计出完美的极少冲突的散列函数

但是对于动态散列表而言，数据集合是频繁变动的，我们无法事先估计将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表，随着数据的慢慢增加，装在因子就会变大，这个时候，我们应该如何处理

我们可以对散列表进行动态扩容，当装载因子过大，则开始扩容，申请一个更大的散列表

### 3.3 如何避免低效的扩容

为了解决一次性扩容太耗时的问题，我们可以将库容操作穿插在插入操作的过程中，分批完成

当装载因子达到阈值时，我们只申请新空间，但并不将老的数据搬移至新的散列表里

当有新的数据要插入时，我们将新数据插入到新散列表中，并且从老的散列表中暗处一个数据到新的散列表中，经过多次这样的操作后，老的散列表中的数据就全部搬移到新的散列表中了，这样没有了几种的一次性数据搬移，插入操作都变得很快了

这期间的查询操作呢？为了兼容新老散列表中的数据，我们先从新的散列表中查找，如果没有再去老的散列表

### 3.4 如何选择冲突解决方案

> 开放寻址法

* 数据都存储在数组中，能够有效利用CPU缓存加快查询速度，故序列化较快
* 删除数据较麻烦
* 散列冲突代价更高
* **适合**数据量小，装载因子小

> 链表法

* 对内存的利用率比开放法好，因为链表节点可以在需要时创建，并不需要像开放法那样提前申请好
* 对大装载因子的容忍度更高
* 对大对象友好，小对象不友好。因为链表要存储指针，所以对于小的对象的存储，链表是较消耗内存的，同时因为链表的不连续的，所以它对CPU缓存也不友好
* **适合**大对象，大数据量的散列表，而且它更加了灵活，支持更多的优化策略，比如用红黑树替代链表


### 3.4 最终设计

> 一个工业级的散列表应该具有的特性

* 支持快速的查询，插入，删除操作
* 内存占用合理，不能浪费过多的内存空间
* 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

> 如何实现

* 设计一个合适的散列函数
* 定义装载因子阈值，并且设计动态扩容策略
* 选择合适的散列冲突解决方法

## 4. 应用

### 4.1 LRU缓存算法

![](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

通过双链表和散列表的结合，我们能做到时间复杂度O(1)

回顾一下之前用链表来实现LRU缓存算法的方法，在插入一个数据之前，我们先在链表中查找是否存在该数据，如果不存在，则直接插入到链表头部，如果存在，则将该点移至链表头部

那么实际上，真正占用空间复杂度的操作有

* 查询
* 增加
* 删除

## 5. 总结

散列表这种结构虽然支持非常高效的数据插入，删除，查找等操作。但是散列表中的数据都是通过散列函数打乱之后无规律存储的，也就是说，**它无法支持按照某种顺序快速遍历数据**，如果需要这么做，我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历

因为散列表式动态数据结构，不停地有数据的插入删除，所以当我们希望能够按顺序遍历时，效率势必会很低，为了解决这个问题，我们将散列表和链表结合在一起。散列表适合查找，而链表/链表的变体适合增删操作，两者结合就可以很棒地完成问题



