![](https://static001.geekbang.org/resource/image/cb/98/cb9015343004911aa717728d1ca9cb98.jpg)

## 1. 定义

Disruptor是一种内存消息队列，它是线程之间用于消息传递的队列，在很多项目中都有广泛应用，之所以如此受青睐，主要是它的性能表现非常优越，可以算的上是最快的内存消息队列了

我们在了解内存消息队列之前，首先来看一下“生产者-消费者模型”。在这个模型中，生产者生产数据，并且将数据放在一个中心存储容器中，之后消费者从中心存储容器中，取出数据消费

这个模型非常好理解，那么我们有没有思考过，这里面存储数据的中心存储容器，是用什么样的数据结构来实现的呢

实际上就是队列，如果我们要实现无界队列，则用链表实现的比较好，因为它天然支持动态扩容，如果是有界队列，则用数组较好。实际上，有界队列的应用场景更加广泛，毕竟我们机器的内存是有限的

在队列的基础上，我们知道循环队列可以很好地弥补普通队列在添加和删除数据的效率损耗。所以大部分需要用到顺序队列的场景中，我们都可以选择用顺序队列中的循环队列

更进一步的，如果同时有多个生产者在并发地往队列中写入数据，就会出现多个生产者写入的数据可能会相互覆盖和多个消费者可能会重复读取的问题

最简单的解决办法就是给这段代码加锁，同一时间只允许一个线程执行add函数，这就相当于这段代码的执行，由并行改成了串行，当然这样的话就会导致多个生产者生产数据时，执行效率的下降，当然我们可以继续优化代码，用CAS（比较并交换）操作减少加锁的粒度

我们来看下Disruotor算法的原理。对于之前的模型，队列支持两个操作，分别是add和delete，而disruptor中，它在添加数据之前，可以先申请可用空闲单元，后续往队列中添加元素，当申请到这组连续的内存单元之后，后续添加元素，就可以不用加锁了，因为这个存储单元是线程独享的，不过申请单元的过程需要加锁

## 2. 总结

常用的内存队列往往采用循环队列来实现，这种方法，对于只有一个生产者和一个消费者的场景，已经足够了，但是存在多个生产者的时候，单纯的循环队列的实现方式，就无法正确工作了。针对这个问题最简单的办法是给线程加锁，但是这样势必会影响到操作的性能，Disruptor采用了两阶段写入的方法，在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据时，就不需要加锁了，写入的性能会因此提高
