![](https://static001.geekbang.org/resource/image/ed/20/ed6942585b0128e402ffeae7f8698f20.jpg)

## 1. 定义

时间复杂度是衡量算法执行效率的一种标准，但是它并不能和性能画上等号。在真实的软件开发过程中，即使是在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率，算法的目的是为了提高代码执行的效率，当算法无法再优化的情况下，我们该如何进一步提升执行效率呢？——————并行计算

### 1.1 并行排序

假设我们要对8G的数据进行排序。我们在传统的O(nlogn)的算法的基础上还可以做出如下的改进

* 对归并排序并行化处理，我们将8G数据分为16个小的数据集合，每个集合包含500mb的数据，我们用16个线程对16个数据集合进行排序。这16个集合分别排序完成后，再对这16个有序集合合并
* 对快排并行化处理，我们将数据的区间划分为16个小区间（16个桶），再将8G的数据划分到对应的区间里，针对这16个小区间的数据，我们启动16个线程，并行排序，排序完成后，得到的就是有序数据了（桶排序的并行版）

:::warning
当然，如果数据的规模不是8G，而是1T，问题的重点不是算法的执行效率，而是数据的读取效率。因为1T的数据肯定是存在硬盘里，如何减少硬盘的IO操作，变成了优化的重点（参考B+树）
:::

### 1.2 并行查找

我们知道散列表的缺点是需要动态扩容，扩容后散列表的内存占用率很低（散列表是基于数组的）

实际上，我们可以把护具随机分割成k份，然后我们针对这k个数据分别构建散列表，这样它的维护成本就贬低了。当某个散列表的装载因子过大时，我们可以对这个散列表单独扩容

当我们要查找某个数据的时候，我们只需要通过16个线程，并行在这16个散列表中查找数据。当我们添加数据时，我们可以选择将该数据装入装载因子最小的那个散列表中，这样也有利于减少散列冲突

### 1.3 并行字符串匹配

我们可以在大文本分割成16个晓文本，并行进行查找。如果因为分割导致在16个晓文本中查找不到的话，我们可以拿每个小文本的前后m个字符（m为关键词的长度）再次进行查找

### 1.4 并行搜索

我们已经学习了DFS，BFS，Dijkstra算法和改进的A*算法。对于BFS，我们也可以对其改造成并行算法

我们需要两个队列来完成扩展顶点的工作。多线程并行处理队列a中的顶点，并将扩展后得到的顶点存储在队列b中，等a中的顶点扩展完成后，a被清空，我们再并行扩展b中的顶点，并将扩展处的顶点存储在a中，这样两个队列循环使用，就可以实现并行的BFS

## 2. 总结

我们在算法没有办法改进的时候，可以通过并行计算来提升整体的执行效率。并行计算非常实用，可以应用在排序，查找，搜索，字符串匹配等方面。它是一个工程的实现思路，尽管和算法关系不大，但是它却是一个实际应用中非常好用的性能优化手段

