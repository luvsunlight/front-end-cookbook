![](https://static001.geekbang.org/resource/image/ab/79/abdc3641bada1a03f4444c36c1bc4879.jpg)

## 1. 定义

![](https://static001.geekbang.org/resource/image/40/1e/4094a733986073fedb6b9d03f877d71e.jpg)

二叉树，顾名思义，每个节点最多有两个节点，左右节点。

![](https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg)

**满二叉树**

* 叶子节点全在最底层
* 除了叶子节点以外，每个节点都有左右两个子节点。

**完全二叉树**

* 叶子节点都在最底下两层
* 最后一层的叶子节点靠左排列
* 除了最后一层，其他层的节点个数都要达到最大

![](https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg)

想要知道为什么完全二叉树是这样定义，我们就要看一下完全二叉树的表示方式

* 基于链表的链式存储法
* 基于数组的顺序存储法

![](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg)

总结一下，如果节点x存储在数组中下标为i的位置，下标为2*i的位置存储的就是左节点，下标为2*i+1存储的就是右子节点，反过来，下标为i/2的存储的就是父节点，这样就可以通过下标计算，所以就可以通过下标计算，把整颗树串起来

当然这样说的是一颗完全二叉树，所以仅仅浪费了一个下标为0的存储位置，如果是非完全的二叉树，就会浪费很多的数组存储空间

![](https://static001.geekbang.org/resource/image/08/23/08bd43991561ceeb76679fbb77071223.jpg)

> 所以，如果数组是完全二叉树，那么用数组存储是最节省内存的一种方式，因为数组的存储方式并不需要像链式存储一样，需要存储额外的左右节点的指针

## 2. 二叉树的遍历

经典的方法有**中序遍历**，**前序遍历**，**后序遍历**。这无非就是节点和其左右子节点遍历打印先后顺序

## 3. 二叉查找树

二叉查找树是二叉树最常用的一种类型，也叫二叉搜索树，它不仅支持快速查找一个数据，还支持快速插入，删除一个数据

二叉查找树要求，在树中的任意一个节点，其左节点的值必须小于该节点的值，右节点的值必须大于该节点的值

![](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)

### 3.1 二叉查找树的查找

![](https://static001.geekbang.org/resource/image/96/2a/96b3d86ed9b7c4f399e8357ceed0db2a.jpg)

### 3.2 二叉查找树的插入

![](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg)

### 3.3 二叉查找树的删除

![](https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg)

删除是最麻烦的一点，需要考虑三种情况

第一种情况，如果删除的节点没有子节点，我们直接将父节点指向该节点的指针置为null

第二种情况，如果只有一个子节点，我们可以让父节点指向子节点

第三种情况，如果有两个节点，我们需要找到该节点的右子树的最小节点，替换到要删除的节点中，然后再删除这个最小节点

> 当然，有一个更取巧的办法，那就是不实际删除该点，而是标记为deleted

### 3.4 二叉查找树的其他操作

还有一个很重要的特性，中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O(n)，非常高效

### 3.5 二叉查找树 vs 散列表

* 可以通过中序遍历直接输出有序排列
* 散列表扩容耗时很多
* 尽管散列表的查询操作时间复杂度是常量级的，但是因为散列冲突的存在，它的时间复杂度不一定比二叉查找树低
* 散列表的构造比二叉查找树要复杂，考虑的东西很多

## 4. 应用

