![](https://static001.geekbang.org/resource/image/01/38/01e51226d435eda4604acc019731c538.jpg)

## 1. 定义

同一个网站链接可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬去相同的页面，我们应该如何避免这些重复的爬取呢？

我们要实现的功能是快速查找和插入，显然散列表，跳表，红黑树等结构都可以达到这些目的，但是对于内存的消耗方面是否可以接受呢？

实际上，分治（哈希分片）和散列表的方法已经是可以实践的工业级了，那么我们有没有更加优化的空间呢？

如果是基于拉链法的散列表的话，拉链过长时，查找的效率就很低，就算是用了跳表来优化，因为链表本身的原因，它对CPU缓存不友好，在数据访问性能方面会打折扣。另外一方面，链表中每个数据都是很长的url，字符串匹配又是一方面的事了

接下来就引入我们今天的主角，位图，假如我们有1kw个整数，整数的范围在1~1亿之间，如何查找某个整数是否在这1kw个整数中呢

我们可以申请一个大小为1亿的数组，每个数组都是Boolean类型，表示该值是否存在。直接用boolean位太浪费内存了，我们可以用一个二进制位bit来表示。

不过一般的位图只能解决数字范围不太大的情况，如果范围一大，就没有优势了。

这个时候布隆过滤器就登场了，它就是为了解决刚才那个问题。

数据范围是1~10亿，我们还是用1亿二进制位大小的位图，通过哈希函数，对数字进行处理，让其落在1亿范围内。这个时候遇到了散列冲突，我们应该怎么办？

我们使用k个哈希函数，对同一个数字进行求哈希值，会得到k个不同的哈希值，我们将这k个不同的值都设为true，也就是说，我们用k个二进制的位来表示一个数字的存在。要找数组的时候，我们只有对应数字的k个哈希值都存在时，我们才认为该数字存在。反之不存在。经过k个哈希函数处理后，都相同的概率就很低了。布隆过滤器的缺点是容易误判，可能某个数字经过布隆过滤器判断存在可能会出现误判。不过一方面我们可以调整哈希函数，一方面很多场景对误判有一定的容忍度。比如一个没有被爬取的网页被认为已经爬取，对搜索引擎来说也不是很大的事。

比如10亿的网页，用散列表来存储可能需要100G的内存，而布隆过滤器采取10倍的空间，也就是100亿个二进制位，换成字节就是1.2G，效率提升非常多，而且布隆过滤器基于数组，对CPU缓存更加友好

## 2. 总结

位图是一种用二进制位来存储数据存在信息的数据结构，缺点是不适合于大范围数据，布隆过滤器正是为这个而出现的，它通过哈希切片，让大范围数据落入小范围中，并且通过多个哈希函数的验证来使散列冲突的可能降至最低。布隆过滤器可能会出现误判，但是一方面误判可以通过哈希函数的调整来尽量规避，另一方面很多场景对这种误判有很高的容忍度。位图和布隆过滤器都很适合用来解决去重的问题。