## 什么是软件工程

在野路子程序员的开发生涯中，或多或少都会遇到这些问题

-   开发没有分析没有设计，上手就写，后期难以维护，加班熬夜去填坑
-   缺少理论指导，遇到新项目不能举一反三，工作平庸
-   遇到需求变更，只能闷头做，无力反抗
-   做项目没计划性，想到哪做到哪，总是延期，比其他同事做的慢
-   不指导如何与团队协作，职业发展遇到瓶颈，无法晋升

很多情况下，我们与其问`未来哪些技术或者知识`会变，不如问`未来哪些技术不会改变`

仔细分析，这些问题不外乎`数据结构`，`算法`，`面向对象思想`，`设计模式`，`软件工程`

技术更新迭代速度很快，难以把握，更难以预测，但是软件开发背后的逻辑却万变不离其宗

## 推荐书籍

-   构建之法
-   人月神话
-   人件
-   知行合一
-   软件工程--实践者的研究方法
-   持续交付走出软件作坊

## 历史衍变

参考建筑工程，整个软件开发过程也被分为了几个阶段：需求定义与分析，设计，实现，测试，交付与维护，这也就是我们常说的软件项目生命周期

同时也就很自然地衍生出了一套最基础的过程模型，瀑布模型

![](https://static001.geekbang.org/resource/image/2e/fa/2ecff3fec361a24f7a290fadc556f9fa.png)

![](https://static001.geekbang.org/resource/image/cc/0c/ccb6fe9bcfa001b27d8c1921b5b2180c.jpg)

:::tip
问题的定义 => 需求分析 => 软件设计 => 程序编码 => 软件测试 => 运维
:::

然而瀑布的特性决定了它只能从上而下流，而且从上到下走完整个周期很长，所以一旦出现了需求的变更，很多事情需要从头再来

基于瀑布模型，又衍生出很多轻量级开发，最后形成了敏捷联盟

![](https://static001.geekbang.org/resource/image/10/5d/108934d6b0497faebe0f573ddcdbac5d.png)

近些年，云计算，微服务这些新技术的产生，也对软件工程产生了影响。云服务让分工更细，更多企业可以将运维，服务器维护，DBA，甚至某些独立服务器交给云服务商，微服务让大团队变成小团队，每个小团队可以更加专注于细分领域，减少相互之间的依赖

> 软件工程 = 过程 + 方法 + 工具

## 工程思维

> Everything is a project

尝试把生活中每件事都当做一个项目来推进，`分析，设计，实施，测试，完成`

![](https://static001.geekbang.org/resource/image/88/a1/881f55121a460da55d6dc5b4a58598a1.png)

## 1. 瀑布模型

一个经典的案例

### 1.1 需求分析

项目立项后，首先，和老板产分的沟通，了解老板的想法是什么，想要做什么样的网站。然对市场上同类型的社交网站进行调研，然后用原型工具设计了网站的原型。

原型拿给老板看，老板再根据自己的想法提供一些反馈，反复沟通确认，在原型设计清楚之后，产品经理开会编写产品设计文档，将整个网站划分为不同的功能模块。

这个时候 pm 最忙，架构师在看网上流行的社交网站用什么架构，程序员，测试看技术文档

### 1.2 软件设计

产品文档确定之后，架构师开始做架构设计，UI 设计师开始设计 UI，测试经理开始针对产品设计文档写测试用例，产品经理还要进一步设计交互

架构师确定了整体架构，写了技术方案文档，开会讨论之后和开发人员讨论设计细节并且确定了分工

这个时候老板的想法发生了一些变化，他决定平台接入网络游戏

产品，UI，架构，测试全部重新开始工作

### 1.3 编码

推迟了很久

### 1.4 测试和运维

bug 一大堆，上线效果很糟糕

瀑布模型的优点在于过程自然简单，每个阶段都有各自的侧重点。但是它最大的问题在于不能及时响应需求变更，越到后期变更代价越大，另外通常要到最后阶段才能看到结果是什么样子的

![](https://static001.geekbang.org/resource/image/88/5c/881b21fa452df38da1604f5a6b55d65c.jpg)

## 2.快速原型模型

先迅速建造一个可以运行的软件原型（不需要考虑质量，架构，性能 etc），然后收集反馈，再反复修改确认，使开发出的软件能够真正反映用户需求，这种开发模型就叫做快速原型模型

快速原型开发注重和客户的交流，但是往往是以牺牲质量为代价的

## 3. 大瀑布拆小瀑布

瀑布模型的很多问题，根源都是周期太长。基于这种思路，产生了很多开发模型。比较典型的主要是`增量模型`和`迭代模型`

### 3.1 增量模型 - 按模块分批次交付

即将待开发的软件系统模块化，然后在每个小模块的开发过程中，应用一个小瀑布模型

**如果拿盖房子比喻的话，就是先盖厕所，再盖厨房，最后卧室**

如果一个模块有问题，或者需要做需求变更，对整体影响也有限，更加灵活和高效率

![](https://static001.geekbang.org/resource/image/d5/a1/d574d834ef428ae2818f8fe903ff98a1.jpg)

但是缺点也很明显

-   需要系统能够模块化
-   对模块的划分很抽象，对系统架构的水平要求高

### 3.2 迭代模型 -- 每次迭代都有一个可用的版本

迭代模型每次只设计和实现产品的一部分，然后逐步完成更多功能

**拿盖房子距离，如果用迭代模型盖房子，首先盖一个茅草屋，快速满足客户对房子的核心需求，然后盖小木屋，小别墅 etc**

在迭代模型中，整个项目被拆分为一系列小的迭代，通常一个迭代的时间都是固定的，不会太长，例如 2-4 周，迭代结束完需要完成一个可以运行的交付版本

![](https://static001.geekbang.org/resource/image/00/45/009b666b98be0ce3cd4362a0479f1845.jpg)

### 3.3 两者的比较

这两个方案很容易混淆，因为都是把大瀑布拆成小瀑布，核心区别主要是在如何拆分项目上

增量是按功能模块来拆分，**迭代模型是按照时间来拆分，看单位时间能完成多少功能**

迭代模型最难的部分在规划每次迭代的内容和要达到的目标。多了可能完不成，少了可能每次迭代工作量不饱和，这需要在实践中去摸索，一个迭代一个迭代的去迭代

每次迭代，用户可能会增加新的需求，所以在开发时间上可能比预期唱，如果是小项目的话，并不建议用迭代模型来开发

## 4. 敏捷开发

### 和瀑布模型的区别

#### 需求分析

敏捷开发的需求，主要是来源小小的用户故事

#### 架构设计

瀑布模型在需求分析完了之后，就需要根据需求做架构设计，而在敏捷开发里，并不会基于完整的用户需求开发，是一种渐进式的架构设计

这种渐进式的架构设计，迭代次数一多，就会出现架构满足不了需求的现象，产生很多冗余代码，通常我们称之为技术债务，需要定期对系统架构进行重构

#### 保证项目质量

在敏捷开发的 sprint 中，并没有专门的测试阶段，这就依赖于开发功能的同时，要编写单元测试和集成测试代码，用自动化的方式辅助完成测试。比如 windows 以前是采用传统的瀑布模型，win10 之后采用敏捷开发，每个月发布更新，稳定性要差一些

#### 发布部署

在敏捷开发中，这种持续构建，持续发布的概念叫做持续集成，因为整个过程是全自动化的

#### 敏捷开发和迭代开发

迭代: 分析需求 => 需求分析文档 => 架构设计 => 编码 => 测试 => 上线
敏捷: 需求拆分为用户故事（用户登录，用户注册，找回密码，修改资料）=> 放在当前 Sprint 的 Backlog（染污清单） => 开发团队成员开始从 Backlog 选择用户故事， 程序员 A 选择了用户登录这个用户故事，他去找产品确定需求细节，然后动手实现

迭代模型本质上是一个小瀑布模型，所以和瀑布模型一样，在刚开始测试的时候是不稳定的。而在敏捷开发中，没有严格的阶段划分。每一个用户故事开发完成，就可以通过持续集成自动发布到测试环境

**敏捷开发**更注重软件开发中人的作用，需要团队成员和客户之间的紧密协作

### 敏捷开发适合环境

-   团队要小
-   团队成员紧密协作
-   领导们支持，敏捷需要扁平化的组织结构,更好地发挥出项目组成员的主动性
-   写代码时有一定的自动化测试代码，要花时间搭好源码管理和持续集成环境

## 5. 我该选择什么过程模型

### 场景一： 外包项目，需要阶段验收

![](https://static001.geekbang.org/resource/image/f9/50/f98018e11ec47c3ce07c7e5e1920b350.jpg)

这个就是`v模型`，不过本质上还是瀑布模型，只不过它更加重视对每个阶段验收测试的过程模型

### 场景二：项目风险高，随时可能中断

增量或者迭代模型进行开发都可以。需要注意的是，在每次交付的时候，要**同时做风险评估**，如果风险过大就不继续后续开发了，及时止损

![](https://static001.geekbang.org/resource/image/5c/cc/5c1f2444754f3ce5ce68e0a790da2bcc.png)

这种强调风险，以风险驱动的方式完善项目的开发模型就是`螺旋模型`

### 场景三： 山寨一款软件产品，希望能够快速上线发布

特点是：项目需求是明确的，不会有什么变化。这时可以选择`增量模型`，划分好模块，先实现核心模块，发布可运行版本，再增量发布其他模块，多模块可以同步开发

### 场景四：客户都没搞清楚想搞什么，但是是个大单子

#### 初始阶段

主要是确定需求边界和主要风险，几乎没有开发工作

#### 细化阶段

主要是确定需求，可以采用快速原型开发，和客户对需求反复确认，需要辅助一定量的开发和测试工作，对代码的质量可以要求比较低

#### 构造阶段

需求确认清楚后，可以使用迭代模型开发，逐步交付产品

#### 交付阶段

重点是测试和部署

![](https://static001.geekbang.org/resource/image/b0/fc/b0091341a7fa31cd26d8a02e7d63e2fc.png)

#### 场景五：我的产品已经上线，但是需要持续维护更新维护

迭代开发

## 软件质量和时间成本的平衡

![](https://static001.geekbang.org/resource/image/da/26/da8781e46fa897bd858cf1e5680f3026.png)



## 总结

-   一个以确认需求为主要目的的项目，就不用花太多时间在代码质量上，低成本，高效做出来才是最重要的
-   一个高风险的项目，则可以采用螺旋模型，出了问题及时止损
-   长时间建加点一直没法上线的项目可以改成增量模型，先上线一个小模块，然后再迭代，逐步上线其他模块
